# マッチングロジック設計 (Phase 5)

## 1. 概要

「価値観マッチング」は本サービスの核となる機能であり、ユーザー同士が共通の価値観や興味に基づいて繋がることを目的とする。
従来のスペック重視（年齢、年収など）のマッチングではなく、内面的な「価値観（Values）」や「ナラティブ（Narrative）」を重視する。

## 2. データ構造: 価値観 (Values)

ユーザーの価値観を以下の要素で構成する。

### 2.1 Explicit Values (明示的価値観)

ユーザーが選択または入力した明確なデータ。

- **Core Values**: 選択式の主要な価値観タグ（例: 「自由」「挑戦」「安定」「創造」）。
- **Tags**: 興味・関心のハッシュタグ（例: #Drizzle, #Travel, #IndieDev）。
- **Mandala Chart**: マンダラチャートの中心および周辺セルに入力されたキーワード。

### 2.2 Vector Representation (ベクトル表現)

- ユーザーのプロフィール文、直近の投稿、自己紹介などをEmbedding化し、意味的な類似性を計算可能にする。
- 使用モデル案: `text-embedding-3-small` (OpenAI) または `supabas-evecs` (local/open source)。

## 3. マッチングアルゴリズム

### 3.1 ハイブリッドスコアリング

複数の要素を組み合わせて「マッチングスコア (0.0 - 1.0)」を算出する。

$$ Score = (w_1 \times TagMatch) + (w_2 \times VectorSim) + (w_3 \times Activity) $$

- **Tag Match**: 共通のタグ数によるJaccard係数的なスコア。
- **Vector Sim**: Embeddingベクトルのコサイン類似度。
- **Activity**: 最終ログイン日時などのアクティブ度（非アクティブユーザーを優先度低にする）。

### 3.2 アルゴリズムの選択肢 (検討中)

| アルゴリズム                | メリット                                                   | デメリット                                       | 採用判定         |
| :-------------------------- | :--------------------------------------------------------- | :----------------------------------------------- | :--------------- |
| **タグ一致 (Rule-based)**   | 実装が容易、結果の説明性が高い（「〇〇が共通しています」） | ニュアンスを拾えない、表記揺れに弱い             | **採用 (Base)**  |
| **ベクトル検索 (Semantic)** | 言葉が違っても意味が近ければマッチする、発見性がある       | 計算コストがかかる、なぜマッチしたか説明しづらい | **採用 (Boost)** |
| **グラフベース (Social)**   | 「友達の友達」などを推奨できる                             | データが蓄積されないと効果が薄い                 | 見送り (Phase 6) |

## 4. マッチングモード仕様

### 4.1 Auto-Matching (自動推奨)

- **概要**: システムが毎日/毎週、おすすめのユーザーを「本日のピックアップ」として提示。
- **UI**: Tinderライクなカードスワイプ、またはリスト表示。
- **ロジック**:
  1.  アクティブユーザーの中から候補をフィルタリング。
  2.  ログインユーザーとのハイブリッドスコアを計算。
  3.  上位N名を提示。
  4.  一度「Skip」したユーザーは一定期間表示しない。

### 4.2 Manual Matching (手動検索)

- **概要**: ユーザーが特定の条件を指定して検索。
- **検索条件**:
  - 特定のタグ（#React, #Design）
  - 価値観カテゴリ
  - 活動地域（任意）
- **UI**: 検索バー + グリッド表示。

## 5. データベース設計方針 (Draft)

### Tables

- `match_preferences`: ユーザーのマッチング希望条件（年齢層、距離など ※今回は価値観重視なので優先度低）。
- `user_embeddings`: ユーザープロフィールのベクトルデータを格納（pgvector使用）。
- `matches`: マッチング成立（相互いいね）の状態管理。
  - `user_id_1`, `user_id_2`, `status` (pending, accepted, rejected), `created_at`

## 6. Phase 5 実装ステップ

1.  **DB Schema Definition**: `matches` テーブルと `pgvector` 導入検討。
2.  **Logic Implementation**:
    - タグベースのスコアリング関数実装。
    - (Optional) OpenAI Embedding API との連携実装。
3.  **UI Implementation**:
    - `matching-manual` 検索画面。
    - `matching-auto` レコメンド表示。
