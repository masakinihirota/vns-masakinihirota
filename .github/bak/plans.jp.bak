# Codex 実行計画（ExecPlans）:

この文書は、実行計画（"ExecPlan"）の要件を説明します。実行計画は、コーディングエージェントが機能やシステム変更を実装するために従う設計書です。読者はこのリポジトリに不慣れな完全な初心者と想定し、作業ツリーとこの単一の ExecPlan ファイルだけが存在する前提で記述してください。過去の計画の記憶や外部コンテキストは存在しないものとします。

## ExecPlans と PLANS.md の使い方

実行可能な仕様（ExecPlan）を作成する際は、PLANS.md の指示に厳密に従ってください。PLANS.md が手元にない場合は、必ず全文を読み返して記憶をリフレッシュしてください。正確な仕様を作成するために、ソース資料を丁寧に読み（必要に応じて再読）ながら進めてください。仕様を作るときは、まず雛形（スケルトン）から始め、調査を進めながら内容を肉付けしてください。

実行可能な仕様（ExecPlan）を実装する際は、ユーザーに「次はどうしますか？」と尋ねるのではなく、次のマイルストーンへ進んでください。ドキュメントの各セクションを最新の状態に保ち、途中で進んだ点や次の手順を明確にするためにリスト項目を追加または分割してください。曖昧さは自律的に解決し、変更は頻繁にコミットしてください。

ExecPlan を議論する際には、変更の理由が明確に分かるように決定ログ（Decision Log）にすべて記録してください。ExecPlans は生きたドキュメントであり、ExecPlan だけから再スタートできることが常に求められます。

要件が厳しい設計や不確実性が高い課題を調査する場合は、マイルストーンを設定してプロトタイプ（概念実証、簡易実装など）を作り、提案が実現可能かを検証してください。外部ライブラリを使用する場合はソースコードを取得して深く調査し、プロトタイプを含めてより完全な実装に向けた指針を作成してください。

## 要件

譲れない要件（NON-NEGOTIABLE REQUIREMENTS）:

- **すべての ExecPlan は完全に自己完結していなければなりません。** ここで言う自己完結とは、現在の文書だけで初心者が成功するために必要な知識と手順がすべて揃っていることを意味します。
- **すべての ExecPlan は生きたドキュメントです。** 進捗や発見、設計の意思決定があった場合には、寄稿者はドキュメントを更新して完全に自己完結した状態を維持する必要があります。
- **すべての ExecPlan は、リポジトリに関する予備知識がない完全な初心者がエンドツーエンドで機能を実装できることを保証しなければなりません。**
- **すべての ExecPlan は、単なる定義の追加ではなく、実際に動作する挙動（ユーザに観測可能な動作）を生み出さなければなりません。**
- **専門用語を使う場合は、必ず平易な言葉で定義してください。** 定義できない用語は使用しないでください。

目的と意図を最優先に示してください。まず短い文章で、この作業がユーザーにとって何をもたらすか（変更後にできるようになること、以前はできなかったこと）、およびその動作をどのように確認するかを説明してください。次に、その成果を得るために必要な具体的手順（編集するファイル、実行するコマンド、観察すべき出力など）を案内してください。

このプランを実行するエージェントは、ファイルの一覧表示、ファイルの読み取り、検索、プロジェクトの実行、テストの実行が可能です。エージェントは事前の文脈を知らず、以前のマイルストーンから自動的に推測することはできません。依存する前提がある場合は、それを繰り返して明示してください。外部のブログやドキュメントへの参照は行わず、必要な知識があればプラン内で自分の言葉で説明してください。もし ExecPlan が別の ExecPlan を基にしている場合、基になる ExecPlan がリポジトリにチェックインされていれば参照して組み込んでください。そうでない場合は、必要なコンテキストをその ExecPlan の内容としてここに含める必要があります。

## 書式

書式は簡潔で厳格です。各 ExecPlan は、始めと終わりに三重バッククォート（```）で囲まれた、`md` ラベル付きの単一のコードブロックである必要があります。内部でコマンド、出力、差分、コードを示す場合は、追加の三重バッククォートで囲まないでください。代わりにその単一のフェンス内にインデント形式で示してください。ExecPlan 内で誤って最外側のフェンスを閉じないよう、明確さのためにインデントを使ってください。各見出しの後には空行を 2 行入れ、`#` および `##` といった見出し構文や、順序付き・順序無しリストの正しい書式を使用してください。

ExecPlan を Markdown (.md) ファイルとして保存し、そのファイルの内容が単一の ExecPlan のみである場合は、最外側の三重バッククォートは省略してください。

本文は平易な散文で記述してください。列挙が必要な場合でも、可能な限り文章形式を優先し、簡潔さを損なう場合のみリストや表を使用してください。`Progress` セクションには必ずチェックリストを使用してください（必須）。ナラティブ（説明）部分は、文章主体で記述してください。


## ガイドライン

自己完結性と平易な言葉遣いを最重要視してください。もし「daemon」「middleware」「RPC gateway」「filter graph」のような通常の英語表現ではない専門用語を導入する場合は、すぐに定義を示し、それがリポジトリ内でどのように現れるか（該当するファイル名やコマンド名）を明示してください。「前に定義した通り」や「アーキテクチャドキュメントに従って」だけでは不十分です。必要な説明はここに埋め込み、たとえ繰り返しになっても明示してください。

一般的な失敗モードを避けてください。未定義の専門用語に依存しないこと。コードがコンパイルするだけで実質的な動作をしないといった「文字通りの定義」に留めないこと。重要な判断を読み手に丸投げしないこと。曖昧性がある場合はプラン内で自分の選択を明確にし、その理由を説明してください。ユーザーが観察できる効果については過剰に説明し、実装の枝葉については簡潔に述べるのがよいでしょう。

計画は観察可能な結果を基準にしてください。実装後にユーザーが何をできるか、実行するコマンド、そして期待される出力を明示してください。受入条件（Acceptance）は、内部的な属性ではなく人が検証できる振る舞いで示してください（例：「サーバー起動後に http://localhost:8080/health にアクセスすると HTTP 200 と OK が返る」）。もし変更が内部的なものであれば、その影響を示す方法（例えば、変更前は失敗するテストが、変更後はパスすることを示す、もしくは新しい振る舞いを使ったシナリオを提示するなど）を記述してください。

リポジトリのコンテキストを明確に指定してください。ファイルはリポジトリ相対パスで明記し、関数やモジュール名も正確に示し、新しいファイルをどこに作るのかも記述してください。複数の領域にまたがる変更がある場合は、どの部分がどのように連携するかを短く説明し、初心者が全体像を把握できるようにしてください。コマンドを示すときは作業ディレクトリと正確なコマンドラインを記載し、結果が環境に依存する場合は前提条件と代替手段を示してください。

冪等性（idempotence）と安全性を考慮してください。手順は何度実行しても破壊や状態のズレを生じないように書いてください。中断や失敗の可能性がある手順については、再試行方法や回復方法を明記してください。マイグレーションや破壊的操作が必要な場合は、バックアップや安全なフォールバック手順を詳述してください。加算的でテスト可能な変更を優先し、段階的に検証できるようにしてください。

検証（Validation）は必須です。テストの実行方法やシステムの起動手順、実際に有用な動作を観察する方法を含めてください。新しい機能や能力には網羅的なテストを設計し、期待される出力やエラーを明記して初心者でも成功・失敗を判断できるようにしてください。可能であれば、単にコンパイルが通るだけでなく、変更が機能していることを証明するためのエンドツーエンドのシナリオ、CLI 呼び出し、HTTP リクエスト/レスポンスの例などを示してください。プロジェクトのツールチェーンに適した正確なテストコマンドとその解釈方法を明記してください。

証拠（エビデンス）を残してください。手順で生成されるターミナルの出力、短い差分、ログなどは、前述の単一のフェンス内にインデント付きの例として含めてください。成功を証明するために必要な最小限の情報に絞って記載してください。差分（パッチ）を含める必要がある場合は、巨大な塊を貼るのではなく、ファイル単位の差分や再現可能な短い抜粋を示すようにしてください。

## マイルストーン

マイルストーンは物語（ナラティブ）であり、単なる官僚的手順ではありません。作業をマイルストーンに分割する場合は、各マイルストーンについて次の内容を短い段落で説明してください: その範囲（スコープ）、マイルストーン終了時に新しく存在すること（以前はなかったもの）、実行するコマンド、および期待する受入条件（Acceptance）。ストーリーとして読みやすく保ち、ゴール、作業、結果、そして証拠の順で示してください。Progress と Milestones は役割が異なります: Milestones は全体の物語を示し、Progress は細かい作業項目の進捗を追跡します。どちらも必要です。省略してしまうと将来的に重要な詳細を見落とす可能性があるため、マイルストーンを短縮するだけで済ませないでください。

各マイルストーンは独立して検証可能であり、実行計画の全体的な目標を段階的に実現するものでなければなりません。

## 生きた計画と設計の意思決定

- ExecPlans は生きたドキュメントです。重要な設計判断を行ったら、その判断とその背景にある考えを `Decision Log` に記録してプランを更新してください。
- ExecPlans には `Progress` セクション、`Surprises & Discoveries` セクション、`Decision Log`、および `Outcomes & Retrospective` セクションを含め、維持する必要があります。これらは省略できません。
- オプティマイザの挙動、性能のトレードオフ、予期しないバグ、あるいはアプローチに影響を与えた逆変換や unapply セマンティクスを発見した場合は、簡潔な証拠（テスト出力が理想）を `Surprises & Discoveries` セクションに記録してください。
- 実装途中で方針を変更した場合は、その理由を `Decision Log` に記録し、`Progress` にその影響を反映してください。プランはチェックリストであると同時に次の実装者へのガイドでもあります。
- 主要なタスクやプラン全体が完了したら、`Outcomes & Retrospective` に何が達成されたか、残件、学んだ教訓をまとめてください。

# プロトタイプ用マイルストーンと並行実装

大きな変更に伴うリスクを軽減する目的で、明示的なプロトタイピングのマイルストーンを含めることは許容され、むしろ推奨されます。例としては、可否を検証するために依存ライブラリに低レベルのオペレータを追加することや、オプティマイザの効果を測定しながら 2 つの合成順序を比較することなどが挙げられます。プロトタイプは加算的（additive）でテスト可能であることが望ましく、そのスコープを「プロトタイピング」と明示してください。実行方法や観察方法、プロトタイプを昇格（採用）するための基準、除外（破棄）する基準を明記してください。

テストが通るようにするために、まず加算的なコード変更を行い、その後必要に応じて整理（削除）していく方法を推奨します。並行実装（例えば、マイグレーション中に古い経路と一時的にアダプタを共存させるような手法）は、リスクを下げる、あるいは大きな移行の際にテストを継続可能にする点で有効です。両方の経路の検証方法と、安全に片方を廃止するためのテスト戦略を記述してください。複数の新しいライブラリや機能領域に取り組む場合、それらを互いに独立して評価するスパイク（短期プロトタイプ）を作成し、外部ライブラリが期待どおりの性能・機能を提供するかを検証してください。

## 良い ExecPlan のスケルトン

```md
# <短く行動に結びつけられる説明>

この ExecPlan は生きたドキュメントです。`Progress`、`Surprises & Discoveries`、`Decision Log`、`Outcomes & Retrospective` のセクションは、作業が進行するにつれ更新を続ける必要があります。

もしリポジトリに PLANS.md がチェックインされている場合は、そのファイルのリポジトリルートからのパスをここに参照し、このドキュメントが PLANS.md に従ってメンテナンスされるべきことを明記してください。

## 目的 / 概要

この変更により何が得られ、どのように動作を確認できるかを数文で説明してください。ユーザーが体験する振る舞いを明確に示してください。

## Progress

細かいステップをチェックボックス付きリストで要約してください。各停止点は必ずここに記録し、必要ならば途中のタスクを「完了」「残り」に分けるなどして明確にしてください。このセクションは常に現在の作業状態を反映していなければなりません。

- [x] (2025-10-01 13:00Z) 例: 完了したステップ
- [ ] 例: 未完了のステップ
- [ ] 例: 部分的に完了したステップ（完了: X; 残り: Y）

進捗速度を測るためにタイムスタンプを活用してください。

## Surprises & Discoveries

実装中に発見した予期せぬ挙動、バグ、最適化、洞察などを記録し、簡潔な証拠を添えてください。

- Observation: …
  Evidence: …

## Decision Log

作業中に行ったすべての意思決定を次の形式で記録してください:

- Decision: …
  Rationale: …
  Date/Author: …

## Outcomes & Retrospective

主要なマイルストーンまたは完了時に、達成したこと、残件、学んだ教訓をまとめ、元の目的と比較してください。

## Context and Orientation

読者が何も知らない前提で、タスクに関連する現在の状態を説明してください。主要なファイルやモジュールはリポジトリ相対パスで示し、非自明な用語は定義してください。過去の計画を参照することは避け、その計画に依存する内容はここで明記してください。

## Plan of Work

編集と追加の順序を文章で説明してください。各編集について、該当ファイルと位置（関数、モジュール）および挿入・変更内容を具体的かつ最小限に示してください。

## Concrete Steps

実行するコマンドと作業ディレクトリを正確に示してください。コマンドが出力を生成する場合は、短い出力例を示して比較できるようにしてください。このセクションは作業の進行に合わせて更新してください。

## Validation and Acceptance

システムの起動・操作手順と観察すべき点を記述してください。受入基準は具体的な入力と出力で表現してください。テストが関係する場合は、"<プロジェクトのテストコマンド> を実行して <N>件がパスする、また新しいテスト <name> は変更前は失敗し変更後は成功する" という形式で示してください。

## Idempotence and Recovery

手順が安全に繰り返せるかどうかを明記してください。リスクのあるステップがある場合は、安全な再試行方法やロールバックの手順を提供し、作業後に環境をクリーンに保つ方法を示してください。

## Artifacts and Notes

重要な出力、差分、抜粋などをインデント付きの例として含めてください。成功を証明するために必要な最小限の情報に絞ってください。

## Interfaces and Dependencies

使用するライブラリ、モジュール、サービスを明記し、その理由を示してください。マイルストーンの完了時に存在すべき型やインタフェース、関数シグネチャを具体的に示してください。例として、`crates/foo/planner.rs` 内に以下のトレイトを定義するなどを挙げてください:

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }

```

上述のガイドラインに従えば、単一のステートレスなエージェントや初心者でも ExecPlan を最初から最後まで読んで作業を実行し、動作が確認できる結果を得られるはずです。評価基準は: 自己完結、自己完結的（self-sufficient）、初心者を導く（novice-guiding）、成果志向（outcome-focused）です。

プランを改訂する際は、変更がドキュメント全体（生きたドキュメントのセクションを含む）に網羅的に反映されていることを確認し、変更内容とその理由をファイル末尾に追記してください。ほとんどすべての項目について「何をしたか」に加え「なぜそうしたか」まで記述することが必須です。
