---
applyTo: "**"
---

# AIモデル実行用 TDD（テスト駆動開発）指示書

本書は、AIモデル（GitHub Copilot など）が本プロジェクトでTDDを確実に実行するための手順と規約を定義します。出力は必ず日本語。対象機能は毎回明示し、他機能の再掲は避けます。

対象リポジトリ/構成:

- 実装: `vns-masakinihirota`
- 設計/要件/テストリスト: `vns-masakinihirota-design`

テスト基盤（確認済）:

- テストランナー: Vitest（`pnpm test` / `vitest.config.js`）
- React/Next.js: React 19, Next 16（`next` スクリプト）
- DOM環境: `jsdom`（@testing-library 系あり）
- Lint/Format: Biome（husky + lint-staged）

注意: `vns-masakinihirota-sample/.github/copilot-instructions.md` を参照する場合、そのファイル名を応答に明記するルールに従ってください。

## 1. 基本原則（Red → Green → Refactor）

1. Red: 先にテストを書き、失敗を確認する
2. Green: 最小実装でテストを通す
3. Refactor: 動作を保ったまま設計・可読性・重複を改善

禁止事項:

- 仕様が曖昧なまま実装を先行しない
- 複数要件の同時実装（テストは粒度を保ち、1件ずつ Green にする）

## 2. 事前準備（AIが毎回行うチェック）

- 対象機能名の明示: `[対象機能名]` を宣言（例: アクセス権限管理）
- 参照設計書の特定: `vns-masakinihirota-design/0020 個別機能 大 -01要件定義書 -02設計書 -03テスト計画書/` 配下の該当ファイル（例: `0012-02-アクセス権限設計書.md`）
- 既存テストリストの確認/新規作成: 同ディレクトリ配下 `…-03-テストリスト.md`（例: `0012-03-アクセス権限テストリスト.md`）
- Serena（タスク管理）: 以下のToDoを作成して進行管理
  - テストリスト作成
  - 最小のRedテスト追加
  - 実装（Green）
  - リファクタ
  - カバレッジ確認と境界値追加

## 3. テストリスト（設計側成果物）の作り方

原則: 対象機能に限定し、全体設計の再掲は禁止（重複・ノイズ防止）。

推奨ファイル: `vns-masakinihirota-design/0020 個別機能 大 -01要件定義書 -02設計書 -03テスト計画書/[機能ID]-03-[対象機能名]テストリスト.md`

最低限の項目（表形式を推奨）:

- テストID（例: TC-001）
- タイトル（短く）
- 種別（Unit / Integration）
- 前提条件（固定データ・権限・ログイン状態等）
- 手順（1. 2. 3.）
- 期待結果（合否基準を明文化）
- 備考（モック方針、エッジ、非機能要件）

例（アクセス権限・RBAC 一部）:

- TC-001: ログイン済みuserがread権限を持つリソースに対し許可される（Unit）
- TC-002: 権限なしの場合は403相当の拒否（Unit）
- TC-003: ロール更新後は新権限が直ちに反映（Integration、キャッシュ/再検証条件を明示）

## 4. 自動テスト実装（実装側成果物）の規約

配置規約（例）:

- ユニットテスト: `vns-masakinihirota/tests/[feature]/*.test.ts(x)`
- UIコンポーネント: `*.test.tsx`（`@testing-library/react` + `@testing-library/jest-dom`）
- ドメイン/ユーティリティ: `*.test.ts`
- API/サーバ処理（必要時）: `tests/api/[route].test.ts`（入出力契約をモック）

命名/内容規約:

- 「何を・なぜ」の it/describe を日本語で明記（仕様がテストから伝わる）
- 可観測な振る舞いにフォーカス（実装詳細には依存しすぎない）
- 単体は徹底的にモックし、副作用（IO/DB/外部API）は切り離す
- 統合は狙いを絞り、事前後片付け（fixtures/reset）を厳密に

DB/外部サービスの扱い:

- Drizzle ORM/Postgres: 単体ではリポジトリ層をモック。統合が必要な場合のみ専用テストDB（`TEST_DATABASE_URL`）を使用可能な形で設計（デフォルトはスキップ可）。
- Supabase: クライアント初期化は抽象化し、認証/ストレージ/権限は Contract をモック可能にする。

カバレッジ:

- `pnpm coverage` で収集、機能単位で主要分岐（許可/拒否/例外/境界）を網羅

## 5. 実行コマンド（PowerShell / Windows）

以下は実行例。必要に応じてAIが自動で実行し、結果を要約して記録します。

```pwsh
# 依存取得（初回/更新時）
pnpm install

# ユニットテスト（ウォッチ）
pnpm test

# UI で失敗箇所を特定したい場合
pnpm test:ui

# カバレッジ（CI/ローカル）
pnpm coverage

# Lint/Format（pre-commitはhuskyで実行されます）
pnpm lint
pnpm format
```

## 6. AIの逐次フロー（毎タスクで実施）

1. SerenaでToDo作成 → 1件のみ in-progress に設定
2. 設計書読み取り → 該当テストリストの更新/新規作成
3. 失敗する最小テストを追加（Red）→ 実行結果を添えて記録
4. 実装でGreen → 実行結果を添えて記録
5. リファクタ（命名/抽象/重複削除/例外設計）
6. 追加の境界/異常/権限逆ケースを書き足し、Green 維持を確認
7. カバレッジ確認（閾値の目安: 機能単位で 80% 以上、クリティカル分岐は100%）
8. Serena ToDo を completed にし、メモリへ簡潔な実績ログを書き込み

コミット運用（参考）:

- 粒度: Red/Green/Refactor をコミット粒度で分けると履歴が明確
- メッセージ: `[TDD][feature] Red: … / Green: … / Refactor: …`

## 7. エッジケース・品質ゲート・失敗時の再試行

想定エッジ:

- 権限反転（許可→拒否/拒否→許可）
- 無効トークン/期限切れ/多重ログイン
- キャッシュ/再検証（Next.js）
- 競合（同時ロール変更）

品質ゲート（AIが自己判定）:

- Build: PASS（実装変更時に `pnpm build` を実施）
- Lint/Typecheck: PASS（Biome/TS）
- Tests: PASS（Vitest 失敗 0）

再試行方針:

- 失敗テストは最大3回まで原因切り分け（モック/前提/実装順序）→ なお失敗する場合はブロック理由を `blocked/` に記録

## 8. 例：アクセス権限（RBAC）でのTDD最小サイクル

1. 設計書: `0012-02-アクセス権限設計書.md` を参照
2. テストリスト: `0012-03-アクセス権限テストリスト.md` に下記を追記
   - TC-001: user+read → 許可（Unit）
   - TC-002: user+readなし → 拒否（Unit）
3. Red: `tests/access-control/permission-check.test.ts` に 2ケースを追加
4. Green: `src/…/permission.ts` の `canAccess(user, resource, action)` を最小実装
5. Refactor: 役割→権限の解決を専用モジュールへ抽出、例外系テストを追加

---

最後に、TDDのTipsと関連アドバイス:

- 小さい失敗→小さい成功→小さい改善のループを高速で回すのが最も生産的です。
- 設計書/テストリストは常に対象機能に限定し、他機能の再掲は避けてノイズを減らしてください。
- UIは `@testing-library/react` の「ユーザー視点」で書くと回帰が起きにくくなります。
- DB/外部依存は単体では大胆にモックし、統合は狙い撃ちで最小限に保ちます。
- 参考にした: `vns-masakinihirota-sample/.github/copilot-instructions.md`
