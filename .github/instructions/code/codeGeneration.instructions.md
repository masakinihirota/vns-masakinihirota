---
applyTo: "*.js,*.jsx,*.ts,*.tsx,*.css,*.scss,*.sass,*.json,*.env"
---

# GitHub Copilot コード生成指示書

use context7

[命名規則](./namingConventions.instructions.md)

## 1. 基本方針

### 1.1. このファイルの役割
このファイルは、GitHub Copilot がコードを生成する際の指示を提供し、プロジェクト全体の一貫性と品質を維持することを目的とします。

### 1.2. 技術スタック
以下の技術スタックに精通したエキスパートとして振る舞ってください。

-   **言語:** TypeScript, Node.js (最新LTSバージョン)
-   **フレームワーク/ライブラリ:** Next.js (最新バージョン、App Router、Server Components活用), React (最新バージョン)
-   **UI:** Shadcn/UI, Radix UI, Tailwind CSS (Radix UIベースでTailwind CSSでスタイリング)
-   **状態管理:** Zustand
-   **バックエンド/DB:** Supabase（型安全なクエリとRLSを実装）
-   **ORM:** Drizzle ORM
-   **スキーマ検証:** Zod
-   **決済:** Stripe
-   **テスト:** Vitest, React Testing Library
-   **UI コンポーネント開発/管理:** Storybook

### 1.3. 熟練者の視点
単に「動くコード」を書くのではなく、**すべての選択肢を知った上で最適な判断を下す「熟練者」の視点**を持ってコードを生成してください。表面上見えない問題や可能性を認識した上で、与えられたコンテキストの中で最適なコードを作成してください。

## 2. コーディング規約

### 2.1. 命名規則
- 命名規則の詳細は `namingConventions-instructions.md` を参照してください。

### 2.2. コード品質の基本原則
-   **品質優先:** 性能よりもシンプルさを優先し、可読性と保守性の高いコードを目指します。
-   **関数型・宣言型プログラミング:** 関数型および宣言型のプログラミングパターンを優先し、クラスベースの実装は避けます。
-   **型安全性:** `any`を使用せず、厳密な型安全を設定してください。
-   **ファイルサイズ:** 1ファイルの行数は500行以内を目安とし、これを超える場合は適切にファイルを分割します。
-   **モジュール化:** 機能または責任ごとに、明確に分離されたモジュールにコードを整理してください。
-   **コンポーネントのエクスポート:** コンポーネントは名前付きエクスポート (`export const MyComponent = ...`) を使用します。

### 2.3. エラーハンドリング
-   **try/catchブロック:** 非同期処理 (`async/await`) では `try/catch` ブロックを使用してエラーを捕捉します。
-   **エラー境界 (Error Boundaries):** Reactコンポーネントにおいて適切なエラー境界を実装し、UIの一部で発生したエラーがアプリケーション全体に影響を与えないようにします。
-   **エラーログ:** エラー発生時には、問題の特定と解決を助けるために、発生箇所や状況がわかるコンテキスト情報を含めてエラーログを記録します。
    - 構造化ログ（JSON形式）でトレースID、ユーザーID、エラー種別を必須項目とします。



## 3. TypeScript と React ガイドライン

### 3.1. TypeScript
-   **TypeScriptの採用:** 全ての新しいコードはTypeScriptで記述します。
-   **関数型プログラミング:** 可能な限り関数型プログラミングの原則に従います。副作用を最小限に抑え、純粋関数を優先してください。
-   **インターフェースと型エイリアス:** データ構造や型定義には、インターフェース (`interface`) または型エイリアス (`type`) を使用します。オブジェクトの形状を定義する場合はインターフェースを、より複雑な型やユーティリティ型を作成する場合は型エイリアスを検討します。
-   **イミュータブルなデータ:** `const` や `readonly` を活用し、可能な限りイミュータブル（変更不可能）なデータを扱います。
-   **Optional Chaining と Nullish Coalescing:** `?.` (Optional Chaining) 演算子と `??` (Nullish Coalescing) 演算子を適切に活用し、null や undefined に起因するエラーを簡潔かつ安全に処理します。
-   **型推論の活用と明示的な型指定のバランス:** TypeScriptの強力な型推論を活用しつつ、関数の引数や返り値など、意図を明確にしたい箇所には明示的な型指定を行います。
-   **`any` 型の回避:** `any` 型の使用は極力避け、より具体的な型を使用するように努めます。どうしても必要な場合は、その理由をコメントで明記することを検討します。
-   **ユーティリティ型の活用:** `Partial`, `Readonly`, `Pick`, `Omit` などのTypeScript組み込みユーティリティ型を効果的に活用し、冗長な型定義を避けます。
-   **公開APIでの配列型:** 公開APIでは `T[]` を避け、`ReadonlyArray<T>` を使用します。内部実装でのみ `Array<T>` を使用することは問題ありません。

### 3.2. React
-   **関数コンポーネントとフック:** コンポーネントは関数コンポーネントとフック (`useState`, `useEffect` など) を使用して記述します。クラスコンポーネントの使用は避けます。
-   **Reactフックのルール遵守:** Reactフックのルール（例: 条件分岐やループ内でのフック呼び出しの禁止）を厳守します。
-   **コンポーネントの型付け:**
    -   子要素 (`children`) を受け取るコンポーネントには、`React.FC` 型ではなく、`React.PropsWithChildren<{ /* props */ }>` や、propsの型定義に `children?: React.ReactNode` を含める方法を推奨します。
    -   コンポーネントのpropsには具体的な型を定義します。
-   **コンポーネントの責務分離:** コンポーネントは小さく、単一の責務に集中するように設計します。複雑なロジックはカスタムフックに切り出すことを検討します。
-   **副作用の管理:** `useEffect` フックは、その依存配列を正しく設定し、不要な再実行を防ぎます。クリーンアップ関数が必要な場合は必ず実装します。
-   **キーの適切な使用:** リストレンダリング時には、各要素にユニークで安定した `key` プロパティを指定します。配列のインデックスを `key` として使用するのは、リストが静的で並び替えやフィルタリングが行われない場合に限定します。

## 4. UI/UX とアクセシビリティ

### 4.1. UI/UX 基本方針
-   **直感的なデザイン:** ユーザーインターフェースは直感的で使いやすく設計します。
-   **レスポンシブデザイン:** 様々なデバイス (PC、タブレット、スマートフォン) での表示を最適化するため、レスポンシブデザインを採用します。
-   **アニメーション仕様:**
    - **追加アニメーション**: fadeIn + slideDown (300ms)
    - **削除アニメーション**: fadeOut + slideUp (200ms)
    - **完了アニメーション**: scaleIn + colorChange (150ms)
    - **ホバー効果**: scale(1.02) + shadow (100ms)
-   **タグ入力の補完:** 一度入力したタグは、次回入力時に補完されるようにします。

### 4.2. アクセシビリティ
-   **キーボード操作:** 全てのインタラクティブな要素がキーボードのみで操作できるようにします。
-   **ARIA属性と役割:** コンポーネントに適切なARIA (Accessible Rich Internet Applications) ラベルと役割を実装し、支援技術による情報の伝達を正確にします。
-   **コントラスト比:** 色のコントラスト比がWCAG (Web Content Accessibility Guidelines) の基準を満たしていることを確認し、視覚障碍のあるユーザーにも配慮します。

## 5. Next.js サーバーアクション

-   Next.jsのサーバーアクションを積極的に使用します。
-   サーバーアクションを利用することで、クライアントサイドでの状態管理やAPI呼び出しを最小限に抑え、パフォーマンスとセキュリティを向上させます。
-   **入力バリデーション:** 入力データのバリデーションにはZodを使用します。
-   **エラー処理:** 適切なエラー処理を実装し、ユーザーに分かりやすいエラーメッセージを提供します。
-   **戻り値のモデル化:** サーバーアクションの戻り値として、成功時とエラー時の両方のケースを明確にモデル化します。

## 6. ドキュメンテーション

-   **コメント:** JSDoc を使った明確なコンテキストを書いてください。コードを修正したらコメントも適切なものにしてください。不要なコメント、食い違いのあるコメントは削除してください。
-   **TSDoc:** IDEのインテリセンス (入力補完やヒント表示) を向上させるため、エクスポートされる関数やコンポーネントにはTSDoc形式のコメントを使用します。
-   **READMEファイル:** プロジェクトのREADMEファイルは常に最新の状態に保ち、セットアップ手順、プロジェクトの概要、主要な機能について記載します。
-   **Supabase関連ドキュメント:** Supabaseのスキーマ定義、RLS (Row Level Security) ポリシー、およびEdge関数を使用する場合は、それらの設計や意図に関するドキュメントを作成します。

## 7. エキスパート視点での実践指針

### 7.1. コード生成の基本原則

*   **多角的な視点を持つこと**: 初心者が書くコードと熟練者が書くコードは、時に全く同じ5行になることがありますが、熟練者は「すべての選択肢を知った上で、今回はこれで十分だ」と判断して書きます。表面上見えない問題や可能性を認識した上でコードを生成してください。
*   **知識の応用**: 提供されたコード例は、一見シンプルですが、学習を重ねることで無数の問題や可能性が隠れています。これらの潜在的な問題点を予測し、解決策をコードに反映させてください。
*   **コンテキストの理解と優先順位付け**: コードの完璧な実装には多くのトレードオフが伴います。**具体的なコンテキスト（例：「信頼性を重視して」「パフォーマンスが最重視」）が与えられた場合は、その優先順位に従ってコードを最適化してください**。

### 7.2. コード品質向上のための具体的な考慮事項

*   **エラーハンドリング**:
    *   `fetch`のような通信関数が5xxエラーでも例外を投げない可能性があることを考慮し、**HTTPステータスコードに基づいた適切なエラー処理**を実装してください。
    *   エラーレスポンスのJSONに意図しないデータが含まれる可能性を防ぐ対策を講じてください。
    *   **Result型（成否を型レベルで保持する）のような明示的なエラー処理手法の導入**を検討してください。
*   **パフォーマンス**:
    *   **N+1問題を回避するため**、可能な限りバッチ処理やまとめてデータを取得するAPIコールを検討してください。
    *   フィールドのオーバーフェッチを防ぎ、**必要なフィールドのみを取得する**ようにしてください。
*   **セキュリティ**:
    *   **入力値がそのままURLに含まれる場合の脆弱性**を認識し、適切な入力値の検証とサニタイゼーションを施してください。
    *   意図しないエンドポイントへのアクセスを防ぐための措置を講じてください。
*   **認証・認可**:
    *   API呼び出しが**無防備な状態でないかを確認し、適切な認証（誰であるか）と認可（何ができるか）の仕組み**（例：JWT、OAuth 2.0）を考慮してコードを設計してください。
*   **信頼性**:
    *   通信先のAPIからの応答がない場合に備え、**タイムアウト機構**を導入してください。
    *   一時的なネットワーク障害に対応するため、**リトライ（指数バックオフを含む）**の仕組みを検討してください。
*   **保守性**:
    *   **ハードコードされたエンドポイントや設定を避け、外部化する**ことを考慮してください。
    *   レスポンスの構造が暗黙知とならないよう、**型安全性を確保**し、APIレスポンスの型定義を明確にしてください。
*   **テスタビリティ**:
    *   **単体テストを容易にするため**、外部通信などの依存をモックに差し替え可能にする**依存性注入の設計**を検討してください。
*   **スケーラビリティ**:
    *   大量のリクエストが発生した場合にシステムが耐えられるかを考慮し、**バッチ処理、非同期キュー、レート制限**などの仕組みの必要性を認識してコードを生成してください。
*   **可観測性**:
    *   本番環境でのデバッグを容易にするため、**レスポンスタイムの計測、構造化されたログ、エラーの追跡**を可能にする仕組みを考慮してください。
*   **チーム開発**:
    *   **チーム全体の文化を念頭に置き、読みやすく、理解しやすく、保守しやすいコード**を生成してください。

### 7.3. AIとしてのあるべき姿勢

*   **「言語化する力、コードを読み解く力」の源泉**: 人間が与える曖昧な指示からも意図を正確に読み取り、また生成したコードが持つ潜在的な問題点を認識し、**その問題点について説明できること**を目指してください。
*   **制約の中での最適解**: 「銀の弾丸は存在しない」ことを理解し、**与えられた制約（時間、リソース、優先順位など）の中で最適なバランスを見つける**ことをエンジニアリングの面白さと捉え、コード作成に臨んでください。
*   **抽象化とライブラリの活用**: すべての概念をゼロから実装するのではなく、ライブラリ、サービスメッシュ、APIゲートウェイなどの既存のツールやプラットフォームレベルでの自動化を活用し、コードをシンプルに保つことを推奨します。

