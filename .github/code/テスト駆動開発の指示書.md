---
applyTo: "*.js,*.jsx,*.ts,*.tsx,*.css,*.scss,*.sass,*.json,*.env"
---

# テスト駆動開発（TDD）指示書 - t-wada方式

このファイルを参照したら、このファイル名を発言してください。

## **このファイルの役割**

このファイルは、GitHub CopilotがTDD（Test-Driven Development）を実践する際の具体的な指示を定義します。t-wada氏による正統的なテスト駆動開発の定義に基づいています。

---

## **テスト駆動開発の基本原則**

### **テスト駆動開発とは何か**

テスト駆動開発は以下の3つのステップを短いサイクルで繰り返す開発手法です：

1. **設計** - 振る舞いの分析とテストリストの作成
2. **レッド** - 失敗するテストを1つだけ書く
3. **グリーン** - テストを成功させる最小限のコードを書く
4. **リファクタリング** - 設計を改善する（必要に応じて）

### **TDDの狙い**

- それまで動作していたものは引き続き全て動作する
- 新しい振る舞いは期待通りに動作する
- システムはさらなる変更の準備ができている
- プログラマとその同僚は、上記の点に自信を持っている

---

## **具体的な開発ステップ**

### **ステップ1：テストリストの作成**

期待される動作をリストアップします。

**やるべきこと：**
- 振る舞いの分析を行い、期待される動作をリストアップ
- テスト容易性と重要度を考慮してテストリストを作成
- 簡単かつ重要度の高いものを上位に配置

**やってはいけないこと：**
- 実装の設計判断を混ぜ込む
- いきなりコードを書き始める
- テストリストを最後まで書いてしまう

```typescript
// テストリストの例
/*
TODO:
====================================
テスト容易性：高 重要度：高
- [ ] 数を文字列に変換する
- [ ] 3の倍数のときは数の代わりに「Fizz」と変換する
- [ ] 5の倍数のときは「Buzz」と変換する
- [ ] 3と5両方の倍数のときは「FizzBuzz」に変換する

テスト容易性：低 重要度：低
- [ ] 1からnまで
- [ ] 1から100まで
- [ ] プリントする
*/
```

### **ステップ2：ひとつテストを書く（レッド）**

テストリストから1つだけ選んで、失敗するテストを書きます。

**やるべきこと：**
- 準備・実行・検証（アサーション）が備わった自動化されたテストを書く
- テストを選ぶ順番を慎重に考える
- アサーションから書き始めて逆向きに書き進める

**やってはいけないこと：**
- アサーションのないテストコードを書く
- 先にテストリストをすべてテストコード化する

```typescript
// テストの例（React Testing Library + Vitest）
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import FizzBuzz from './FizzBuzz';

describe('FizzBuzz', () => {
  it('数を文字列に変換する', () => {
    render(<FizzBuzz number={1} />);
    expect(screen.getByText('1')).toBeInTheDocument();
  });
});
```

### **ステップ3：テストを成功させる（グリーン）**

失敗するテストを成功させる最小限のコードを書きます。

**やるべきこと：**
- テストを成功させる最小限の実装
- 新しいテストの必要性に気づいたらテストリストに追加
- テストが成功したら「済」マークをつける

**やってはいけないこと：**
- アサーションを削除してテストを成功させる
- テスト対象を動かした値をコピーして期待値にペーストする
- テストを書きながらリファクタリングも一緒にやる

```typescript
// 最小限の実装例
const FizzBuzz: React.FC<{ number: number }> = ({ number }) => {
  return <div>{number.toString()}</div>;
};

export default FizzBuzz;
```

### **ステップ4：リファクタリング**

必要に応じてコードの設計を改善します。

**やるべきこと：**
- コードをよりシンプルで理解しやすいものにする
- 重複の排除
- 責任の分離

**やってはいけないこと：**
- 必要以上のリファクタリング
- 早すぎる抽象化や共通化

### **ステップ5：繰り返し**

テストリストが空になるまで、ステップ2-4を繰り返します。

---

## **自動テストの条件**

### **必須条件**

#### **自己検証可能**
- テストは成功か失敗かの2つの結果のみ
- 人間の目を介さずに自分で判断できる

#### **繰り返し可能（Repeatable）**
- 誰が、いつ、どこで実行しても同じ結果
- 手動でのデータリセットやファイル削除が不要

### **強く推奨される性質**

#### **独立している（Independent/Isolated）**
- テストが他のテストに影響を与えない
- 実行順序に関係なく同じ結果

#### **高速**
- テストの実行が速い
- 頻繁な実行が可能

---

## **Vitestを使用したテスト実装ガイドライン**

### **基本的なテストの書き方**

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import '@testing-library/jest-dom';
import ComponentName from './ComponentName';

describe('ComponentName', () => {
  it('should render the component with initial text', () => {
    render(<ComponentName />);
    expect(screen.getByText('Hello')).toBeInTheDocument();
  });

  it('should change text on button click', () => {
    render(<ComponentName />);
    fireEvent.click(screen.getByRole('button'));
    expect(screen.getByText('Clicked!')).toBeInTheDocument();
  });
});
```

### **非同期処理のテスト**

```typescript
it('should load data asynchronously', async () => {
  render(<AsyncComponent />);

  // 非同期処理の完了を待つ
  const loadedData = await screen.findByText('Loaded Data');
  expect(loadedData).toBeInTheDocument();
});
```

### **モックの使用**

```typescript
import { vi } from 'vitest';

it('should call the onClick handler', () => {
  const mockOnClick = vi.fn();
  render(<Button onClick={mockOnClick}>Click me</Button>);

  fireEvent.click(screen.getByRole('button'));
  expect(mockOnClick).toHaveBeenCalledTimes(1);
});
```

---

## **React/Next.jsでのTDD実践指針**

### **コンポーネントのテスト**

1. **レンダリングテスト** - コンポーネントが正しく表示されるか
2. **イベントハンドリングテスト** - ユーザーの操作に正しく反応するか
3. **プロップステスト** - プロップスが正しく処理されるか
4. **状態変更テスト** - 状態の変更が正しく反映されるか

### **Server Actionsのテスト**

```typescript
import { describe, it, expect, vi } from 'vitest';
import { createUser } from './actions';

describe('createUser Server Action', () => {
  it('should create user successfully', async () => {
    const formData = new FormData();
    formData.append('name', 'Test User');
    formData.append('email', 'test@example.com');

    const result = await createUser(formData);

    expect(result.success).toBe(true);
    expect(result.data).toEqual({
      name: 'Test User',
      email: 'test@example.com'
    });
  });
});
```

---

## **よくある誤解と注意点**

### **テスト駆動開発でないもの**

- 設計せずにいきなりテストコードを書き始めること
- テスティングフレームワークを使うことを指す
- テストを書けば信頼性が上がるという考え
- 品質保証の手法である

### **テストファーストでないもの**

- 最初にテストコードを全部書いてから実装すること

---

## **AIへの具体的な指示**

### **テストリスト作成時**

```
期待される動作をリストアップし、テスト容易性と重要度で優先順位を付けてください。
実装の詳細ではなく、振る舞いに焦点を当ててください。
```

### **テスト作成時**

```
テストリストから1つだけ選んで、準備・実行・検証が含まれた失敗するテストを書いてください。
アサーションから逆向きに書き進めてください。
```

### **実装時**

```
テストを成功させる最小限のコードを書いてください。
過度な実装や早すぎる抽象化は避けてください。
```

### **リファクタリング時**

```
テストを変更せずに、コードをよりシンプルで理解しやすいものにリファクタリングしてください。
すべてのテストが通ることを確認してください。
```

---

## **TDDの効果**

### **短期的効果**

- 開発者のモチベーション向上
- デバッグ時間の削減
- テスト対象の理解促進
- 設計改善のきっかけ

### **長期的効果**

- 記憶力・把握力の限界を補う
- 属人性の軽減
- 継続的な品質向上
- 根拠ある自信の醸成

---

## **Tips**

- **コードの動作に対する不安が退屈に変わる**まで、テストとコーディングを繰り返す
- **小さな挑戦と成功を繰り返す**ことでゲーム感覚で開発する
- **常に必要十分かつシンプルな設計を維持**する
- **フィードバックと改善のプロセス**を組み込んで答えに近づいていく
