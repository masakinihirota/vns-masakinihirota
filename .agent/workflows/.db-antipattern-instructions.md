---
trigger: always_on
---

# データベース設計アンチパターン判定指示書

**要約**: PostgreSQL準拠のSQLアンチパターン検出とレポート生成

## 実行フレームワーク（KERNEL準拠）

```
Input:
  - データベーススキーマ（DDL: schema.sql）
  - SQLクエリ（migrations/*.sql、ORM生成SQL）
  - アプリケーションコード（TypeScript/Python等）

Task: SQLアンチパターンの検出と修正提案

Constraints:
  - 対象DB: PostgreSQL 14以降（Supabase推奨）
  - 重大度: Critical（即修正）、High（計画的修正）、Medium（改善推奨）、Low（任意）
  - チェック範囲: シーン別（新規設計/コードレビュー/本番前監査）
  - 自動化: SQLFluff、pgTAP、grepコマンド活用

Output:
  - Markdown形式レポート（重大度順、該当箇所明記）
  - 修正SQL例（実行可能、Before/After）
  - 自動検証コマンド（再現可能）
```

## 概要

この指示書は、AIがデータベース設計・SQL・アプリケーションコードをレビューし、SQLアンチパターンの有無を判定するためのガイドラインです。SQLアンチパターンとは、問題を解決しようとした結果、他の問題を生じさせてしまうような技法を指します。

---

## 重大度分類

| 重大度       | 定義                                       | 影響範囲                     | 対象アンチパターン                                                                       |
| ------------ | ------------------------------------------ | ---------------------------- | ---------------------------------------------------------------------------------------- |
| **Critical** | セキュリティリスク、データ損失の可能性     | 即座に本番環境に影響         | #19 パスワード平文、#20 SQLインジェクション                                              |
| **High**     | データ整合性問題、重大なパフォーマンス劣化 | 運用・保守に重大な支障       | #4 外部キー嫌い、#9 丸め誤差、#25 外部キー誤用、#11 ファントムファイル                   |
| **Medium**   | 保守性低下、拡張性の制限、軽度の性能問題   | 将来的なリファクタリング必要 | #1 ジェイウォーク、#5 EAV、#6 ポリモーフィック関連、#12 インデックス問題、#16 貧者の検索 |
| **Low**      | コーディング規約、ベストプラクティス違反   | コード品質の向上             | #18 暗黙の列、#21 疑似キー潔癖症、#24 ストアドプロシージャ論争                           |

---

## シーン別チェックリスト

### 🆕 新規設計時（必須5項目 - 15分以内）

| #   | パターン                | 重大度   | 検証方法                              | 備考                             |
| --- | ----------------------- | -------- | ------------------------------------- | -------------------------------- |
| 20  | **SQLインジェクション** | Critical | コードレビュー必須                    | プリペアドステートメント使用確認 |
| 19  | **パスワード平文**      | Critical | `grep -n "password.*TEXT" schema.sql` | bcrypt/Argon2ハッシュ必須        |
| 4   | **外部キー嫌い**        | High     | `grep -c "FOREIGN KEY" schema.sql`    | 0件の場合は要確認                |
| 9   | **丸め誤差**            | High     | `grep -n "FLOAT\|DOUBLE" schema.sql`  | NUMERIC型に変更                  |
| 25  | **外部キー誤用**        | High     | ERD確認、参照方向チェック             | 「多」側に外部キー配置           |

**自動検証コマンド**:

```bash
# Critical/High項目の一括チェック
grep -n "FLOAT\|DOUBLE" schema.sql && echo "❌ 丸め誤差リスク"
grep -n "password.*TEXT" schema.sql && echo "❌ パスワード平文"
grep "FOREIGN KEY" schema.sql || echo "⚠️ 外部キーなし"
```

### 🔍 コードレビュー時（追加10項目 - 30分以内）

上記5項目に加えて：

| #   | パターン                 | 重大度 | 重点確認事項             |
| --- | ------------------------ | ------ | ------------------------ |
| 1   | ジェイウォーク           | Medium | カンマ区切りリスト検出   |
| 5   | EAV                      | Medium | 汎用属性テーブルの有無   |
| 6   | ポリモーフィック関連     | Medium | `issue_type`のような列   |
| 12  | インデックスショットガン | Medium | 全列インデックスor未定義 |
| 13  | NULL誤用                 | Medium | `WHERE col = NULL`検索   |
| 16  | 貧者の検索               | Medium | `LIKE '%keyword%'`多用   |
| 18  | 暗黙の列                 | Low    | `SELECT *`の使用         |
| 22  | エラー処理欠如           | High   | try-catchの有無          |

### 🚀 本番前監査（全25項目 - 2時間）

全項目チェック + 以下を追加：

- パフォーマンステスト（EXPLAIN ANALYZE）
- セキュリティスキャン（SQLインジェクション、XSS）
- バックアップ・リストア検証
- マイグレーションテスト（ロールバック含む）

---

## アンチパターンの分類

アンチパターンは以下の4つのカテゴリーに分類されます：

### 1. データベース論理設計のアンチパターン

テーブル構造、列、関連（リレーションシップ）の設計に関する問題

### 2. データベース物理設計のアンチパターン

データ型、インデックス、ファイル格納方法に関する問題

### 3. クエリのアンチパターン

SELECT、UPDATE、DELETE などのSQLクエリに関する問題

### 4. アプリケーション開発のアンチパターン

SQLとアプリケーションコードの統合に関する問題

---

## チェックリスト：論理設計アンチパターン

### 1. ジェイウォーク（Jaywalking）- 信号無視

**問題パターン**: カンマ区切りのリストを1つの列に格納している

**検出ポイント**:

- VARCHAR列にカンマ区切りで複数のIDや値を格納
- 多対多の関連を交差テーブルなしで実装
- REGEXP や LIKE '%value%' での検索が必要になる設計

**危険なコード例**:

```sql
CREATE TABLE Products (
  product_id SERIAL PRIMARY KEY,
  account_id VARCHAR(100) -- カンマ区切りで '12,34,56' のように格納
);
```

**解決策**: 交差テーブル（中間テーブル）を作成し、正規化を行う

---

### 2. ナイーブツリー（Naive Trees）- 素朴な木

**問題パターン**: 階層構造を隣接リストのみで管理している

**検出ポイント**:

- 自己参照の parent_id のみで階層を表現
- 階層全体を取得するために複数回のJOINが必要
- 深い階層の取得が困難または非効率

**危険なコード例**:

```sql
CREATE TABLE Comments (
  comment_id SERIAL PRIMARY KEY,
  parent_id BIGINT,
  comment TEXT,
  FOREIGN KEY (parent_id) REFERENCES Comments(comment_id)
);
```

**解決策**:

- 経路列挙（Path Enumeration）
- 入れ子集合（Nested Sets）
- 閉包テーブル（Closure Table）
- データベースの再帰クエリ機能（CTE）

---

### 3. IDリクワイアド（ID Required）- とりあえずID

**問題パターン**: すべてのテーブルに無条件で `id` という疑似キー列を追加

**検出ポイント**:

- 自然キーが存在するのに `id` 列を別途作成
- 交差テーブルに `id` 列があり、複合キーが重複を許可
- 列名が `id` で冗長なインデックス

**危険なコード例**:

```sql
CREATE TABLE ArticleTags (
  id SERIAL PRIMARY KEY,  -- 不要な可能性
  article_id BIGINT NOT NULL,
  tag_id BIGINT NOT NULL
  -- article_id と tag_id の組み合わせの一意性が保証されない
);
```

**解決策**: 適切な複合主キーまたは自然キーを検討する

---

### 4. キーレスエントリ（Keyless Entry）- 外部キー嫌い

**問題パターン**: 外部キー制約を定義していない

**検出ポイント**:

- 関連テーブル間で FOREIGN KEY が未定義
- 参照整合性をアプリケーションコードのみで管理
- 孤立したレコードが発生している可能性

**危険なコード例**:

```sql
CREATE TABLE Bugs (
  bug_id SERIAL PRIMARY KEY,
  reported_by BIGINT  -- 外部キー制約なし
);
```

**解決策**: 適切な FOREIGN KEY 制約を定義する

---

### 5. EAV（Entity-Attribute-Value）- エンティティ・アトリビュート・バリュー

**問題パターン**: 属性を行として格納する汎用的なテーブル設計

**検出ポイント**:

- `entity_id`, `attribute_name`, `attribute_value` のような列構造
- 動的な属性追加が目的の設計
- データ型の制約が効かない

**危険なコード例**:

```sql
CREATE TABLE IssueAttributes (
  issue_id BIGINT NOT NULL,
  attr_name VARCHAR(100) NOT NULL,
  attr_value VARCHAR(100),
  PRIMARY KEY (issue_id, attr_name)
);
```

**解決策**:

- シングルテーブル継承
- 具象テーブル継承
- クラステーブル継承
- 半構造化データ（JSON型）

---

### 6. ポリモーフィック関連（Polymorphic Associations）

**問題パターン**: 1つの外部キー列で複数の親テーブルを参照

**検出ポイント**:

- `issue_type` のような列で参照先テーブルを指定
- 外部キー制約が定義できない
- 結合時に動的なテーブル切り替えが必要

**危険なコード例**:

```sql
CREATE TABLE Comments (
  comment_id SERIAL PRIMARY KEY,
  issue_type VARCHAR(20),  -- 'Bugs' または 'FeatureRequests'
  issue_id BIGINT NOT NULL
  -- 外部キー制約が定義できない
);
```

**解決策**:

- 共通の親テーブル（スーパータイプ）を作成
- 交差テーブルを複数作成

---

### 7. マルチカラムアトリビュート（Multi-Column Attributes）- 複数列属性

**問題パターン**: 同じ属性のために複数の列を定義

**検出ポイント**:

- `tag1`, `tag2`, `tag3` のような連番列
- `phone1`, `phone2`, `phone3` のような同種の列
- 検索時にすべての列を OR で結合

**危険なコード例**:

```sql
CREATE TABLE Bugs (
  bug_id SERIAL PRIMARY KEY,
  tag1 VARCHAR(20),
  tag2 VARCHAR(20),
  tag3 VARCHAR(20)
);
```

**解決策**: 従属テーブルを作成し、1対多の関連として正規化

---

### 8. メタデータトリブル（Metadata Tribbles）- メタデータ大増殖

**問題パターン**: データ値に基づいてテーブルや列を分割

**検出ポイント**:

- `Bugs_2021`, `Bugs_2022`, `Bugs_2023` のようなテーブル
- `revenue2021`, `revenue2022` のような年ごとの列
- 新しいデータのためにスキーマ変更が必要

**危険なコード例**:

```sql
CREATE TABLE Bugs_2021 (...);
CREATE TABLE Bugs_2022 (...);
CREATE TABLE Bugs_2023 (...);
```

**解決策**:

- 単一テーブルに統合し、日付列で区別
- 必要に応じてパーティショニング機能を利用

---

## チェックリスト：物理設計アンチパターン

### 9. ラウンディングエラー（Rounding Errors）- 丸め誤差

**問題パターン**: 金額や精密な数値に FLOAT/DOUBLE を使用

**検出ポイント**:

- 金額計算に FLOAT または DOUBLE 型を使用
- 等価比較（=）で期待通りに動作しない
- 累積計算で誤差が発生

**危険なコード例**:

```sql
CREATE TABLE Accounts (
  hourly_rate FLOAT  -- 丸め誤差が発生
);
```

**解決策**: NUMERIC または DECIMAL 型を使用（例: `NUMERIC(9,2)`）

---

### 10. サーティワンフレーバー（31 Flavors）- 限定値の列定義

**問題パターン**: ENUM や CHECK 制約で値を限定

**検出ポイント**:

- ENUM 型で値を制限
- CHECK 制約で IN リストを指定
- 値の追加・変更でスキーマ変更が必要

**危険なコード例**:

```sql
CREATE TABLE Bugs (
  status TEXT CHECK (status IN ('NEW', 'IN PROGRESS', 'FIXED'))
);
```

**解決策**: 参照テーブル（ルックアップテーブル）を作成し、外部キーで参照

---

### 11. ファントムファイル（Phantom Files）- 幻のファイル

**問題パターン**: 画像などのファイルをDB外に保存し、パスのみを格納

**検出ポイント**:

- ファイルパスを VARCHAR で格納
- 外部ファイルとDBの同期が取れない可能性
- バックアップ・トランザクション・削除の整合性問題

**危険なコード例**:

```sql
CREATE TABLE Screenshots (
  screenshot_path TEXT  -- ファイルシステム上のパス
);
```

**解決策**:

- BYTEA型でDB内に格納（要件による）
- クラウドストレージとの整合性管理を実装
- 削除・更新時の同期処理を確実に実装

---

### 12. インデックスショットガン（Index Shotgun）- 闇雲インデックス

**問題パターン**: インデックスの過不足

**検出ポイント**:

- インデックスがまったく定義されていない
- すべての列にインデックスが定義されている
- 主キーに対する冗長なインデックス
- 使用されないインデックス

**危険なコード例**:

```sql
CREATE TABLE Bugs (
  bug_id SERIAL PRIMARY KEY,
  summary VARCHAR(80),
  CREATE INDEX ON Bugs (bug_id);     -- 主キーと重複
  CREATE INDEX ON Bugs (summary);    -- 長い文字列へのインデックス
  CREATE INDEX ON Bugs (bug_id, date_reported, status);  -- 使用頻度が低い複合インデックス
);
```

**解決策**:

- クエリパターンを分析してインデックスを設計
- EXPLAIN で実行計画を確認
- MENTOR原則に従う

---

## チェックリスト：クエリのアンチパターン

### 13. フィア・オブ・ジ・アンノウン（Fear of the Unknown）- NULLの誤用

**問題パターン**: NULLを不適切に扱う

**検出ポイント**:

- `WHERE column = NULL` （正しくは `IS NULL`）
- NULLを含む演算で予期しない結果
- NULLを避けるために不適切なデフォルト値を使用

**危険なコード例**:

```sql
SELECT * FROM Bugs WHERE assigned_to = NULL;  -- 結果が返らない
SELECT first_name || ' ' || middle_initial || ' ' || last_name FROM Accounts;  -- NULLがあると全体がNULL
```

**解決策**:

- `IS NULL` / `IS NOT NULL` を使用
- COALESCE 関数でデフォルト値を設定

---

### 14. アンビギュアスグループ（Ambiguous Groups）- 曖昧なグループ

**問題パターン**: GROUP BY に含まれない非集約列を SELECT

**検出ポイント**:

- GROUP BY 句にない列を SELECT で指定
- 集約関数なしで GROUP BY を使用
- 単一値の原則に違反

**危険なコード例**:

```sql
SELECT product_id, MAX(date_reported), bug_id  -- bug_id は曖昧
FROM Bugs
GROUP BY product_id;
```

**解決策**:

- サブクエリで最大値の行を特定
- ウィンドウ関数を使用
- 相関サブクエリを使用

---

### 15. ランダムセレクション（Random Selection）

**問題パターン**: ランダムな行取得の非効率な実装

**検出ポイント**:

- `ORDER BY RANDOM()` でソート
- 大量データでのパフォーマンス問題

**危険なコード例**:

```sql
SELECT * FROM Bugs ORDER BY RANDOM() LIMIT 1;  -- 全行をソート
```

**解決策**:

- 主キーの範囲からランダム選択
- アプリケーション側でランダム値を生成

---

### 16. プアマンズサーチエンジン（Poorman's Search Engine）- 貧者の検索

**問題パターン**: LIKE や正規表現での全文検索

**検出ポイント**:

- `LIKE '%keyword%'` での検索
- `REGEXP` での検索
- インデックスが使用されない検索

**危険なコード例**:

```sql
SELECT * FROM Bugs WHERE description LIKE '%crash%';
```

**解決策**:

- データベースの全文検索機能を使用
- 検索エンジン（Elasticsearch等）の導入

---

### 17. スパゲッティクエリ（Spaghetti Query）

**問題パターン**: 複雑すぎる単一クエリ

**検出ポイント**:

- 多数のテーブルを結合
- デカルト積が発生
- 1つのクエリで複数の集計を試みる

**危険なコード例**:

```sql
SELECT
  COUNT(bp.product_id) AS how_many_products,
  COUNT(dev.account_id) AS how_many_developers,
  COUNT(b.bug_id) / COUNT(dev.account_id) AS avg_bugs_per_developer
FROM Bugs b
JOIN BugsProducts bp ON (b.bug_id = bp.bug_id)
JOIN Accounts dev ON (b.assigned_to = dev.account_id)
JOIN Accounts cust ON (b.reported_by = cust.account_id);
```

**解決策**: クエリを分割し、必要に応じてアプリケーション側で結合

---

### 18. インプリシットカラム（Implicit Columns）- 暗黙の列

**問題パターン**: SELECT \* やINSERTでの列省略

**検出ポイント**:

- `SELECT *` の多用
- INSERT で列名を省略
- 列追加時に既存コードが壊れる可能性

**危険なコード例**:

```sql
SELECT * FROM Bugs;
INSERT INTO Accounts VALUES (123, 'billkarwin', ...);
```

**解決策**: 列名を明示的に指定

---

## チェックリスト：アプリケーション開発アンチパターン

### 19. リーダブルパスワード（Readable Passwords）- 読み取り可能パスワード

**問題パターン**: パスワードを平文で格納

**検出ポイント**:

- パスワード列が TEXT で暗号化なし
- ハッシュ化されていないパスワード
- 復号可能な暗号化

**危険なコード例**:

```sql
INSERT INTO Accounts (password) VALUES ('xyzzy');  -- 平文
```

**解決策**:

- 安全なハッシュ関数（Argon2, bcrypt等）を使用
- ソルトを付与してハッシュ化

---

### 20. SQLインジェクション（SQL Injection）

**問題パターン**: 動的SQLの文字列連結

**検出ポイント**:

- ユーザー入力を直接SQL文字列に連結
- プレースホルダー（パラメータ化クエリ）未使用
- エスケープ処理の不備

**危険なコード例**:

```python
query = f"SELECT * FROM Bugs WHERE bug_id = {bugid}"  -- 危険
```

**解決策**:

- プリペアドステートメント（パラメータ化クエリ）を使用
- 入力値のバリデーション

---

### 21. シュードキー・ニートフリーク（Pseudokey Neat Freak）- 疑似キー潔癖症

**問題パターン**: 主キーの欠番を埋めようとする

**検出ポイント**:

- 連番の欠番を検出・補填するコード
- 主キー値の再割り当て
- 外部システムとのID同期問題

**解決策**: 欠番は無視し、新しい行には新しいIDを割り当てる

---

### 22. シー・ノー・エビル（See No Evil）- 臭いものに蓋

**問題パターン**: エラー処理の欠如

**検出ポイント**:

- API戻り値のチェックなし
- 例外処理の不備
- SQLエラーメッセージの無視

**危険なコード例**:

```python
cursor.execute(query, parameters)  # エラーチェックなし
for row in cursor:
    print(row)
```

**解決策**: 適切なエラーハンドリングとログ出力

---

### 23. ディプロマティック・イミュニティ（Diplomatic Immunity）- 外交特権

**問題パターン**: データベースへのベストプラクティス非適用

**検出ポイント**:

- データベースのバージョン管理がない
- テストデータ・テストコードがない
- ドキュメントがない
- コードレビューの対象外

**解決策**:

- データベースマイグレーションツールを使用
- データベース変更もバージョン管理対象に
- テストを作成

---

### 24. スタンダード・オペレーティング・プロシージャ（Standard Operating Procedure）

**問題パターン**: 常にストアドプロシージャを使用する（または使用しない）

**検出ポイント**:

- すべてのSQLをストアドプロシージャに
- 柔軟性のないアーキテクチャ
- デバッグ・テストの困難さ

**解決策**: 状況に応じて適切な方法を選択

---

### 25. 外部キーの誤った使い方

**問題パターン**: 外部キー制約の設計ミス

**検出ポイント**:

- 参照方向の逆転（1対多の「1」側に外部キー）
- 作成前のテーブルを参照
- データ型の不一致
- NULLを許可した外部キー列での参照整合性問題

**危険なコード例**:

```sql
-- 親テーブル（Parent）に外部キーを定義（逆）
CREATE TABLE Parent (
  parent_id INT PRIMARY KEY,
  child_id INT NOT NULL,
  FOREIGN KEY (child_id) REFERENCES Child(child_id)
);
```

**解決策**: 外部キーは「多」側のテーブルに定義

---

## 判定フロー（KERNEL準拠）

### Step 1: スキーマ検証（論理設計・物理設計）

```
Input: DDLファイル（schema.sql、migrations/*.sql）
Task: アンチパターン #1-12 の検出
Constraints:
  - PostgreSQL 14構文準拠
  - 外部キー必須（CASCADE設定確認）
  - NUMERIC型推奨（FLOAT/DOUBLE禁止）
Output:
  - 検出リスト（重大度High以上のみ表示）
  - 修正DDL例
```

**検証項目**:

1. テーブル定義を確認（#3 IDリクワイアド、#7 マルチカラム、#8 メタデータ大増殖）
2. 列のデータ型を確認（#9 丸め誤差、#10 限定値列）
3. 主キー・外部キーを確認（#4 外部キー嫌い、#25 外部キー誤用）
4. インデックスを確認（#12 インデックスショットガン）

**自動検証コマンド**:

```bash
# SQLFluff（リンター）
sqlfluff lint migrations/*.sql --dialect postgres

# アンチパターン検出
grep -n "FLOAT\|DOUBLE" schema.sql  # #9 丸め誤差
grep -n "CHECK.*IN" schema.sql      # #10 限定値列
grep -c "FOREIGN KEY" schema.sql    # #4 外部キー嫌い（0件は要注意）
```

---

### Step 2: リレーションシップ検証

```
Input: ERD（Entity-Relationship Diagram）、DDL
Task: 関連の妥当性確認
Constraints:
  - 1対多: 「多」側に外部キー
  - 多対多: 交差テーブル必須
  - 階層構造: 閉包テーブルまたはCTE使用
Output: 関連図の修正案
```

**検証項目**:

1. テーブル間の関連を確認（#1 ジェイウォーク、#6 ポリモーフィック関連）
2. 1対多、多対多の関連が適切か確認（#7 マルチカラム）
3. 外部キー制約が定義されているか確認（#4 外部キー嫌い）
4. 階層構造の実装方法確認（#2 ナイーブツリー）

---

### Step 3: クエリ検証

```
Input: SQLクエリ（*.sql）、ORM生成SQL
Task: アンチパターン #13-18 の検出
Constraints:
  - EXPLAIN ANALYZE実行（遅いクエリ検出）
  - N+1問題チェック
  - インデックス使用確認
Output:
  - 遅いクエリリスト（実行時間100ms以上）
  - 改善SQL例
```

**検証項目**:

1. `SELECT *` の使用を確認（#18 暗黙の列）
2. `GROUP BY` と `SELECT` の整合性を確認（#14 曖昧なグループ）
3. `NULL` の扱いを確認（#13 NULL誤用）
4. `LIKE/REGEXP` での検索を確認（#16 貧者の検索）
5. 複雑すぎるJOINを確認（#17 スパゲッティクエリ）

**自動検証コマンド**:

```sql
-- 遅いクエリ検出（PostgreSQL）
EXPLAIN ANALYZE SELECT ...; -- Execution Timeが100ms以上は要改善

-- インデックス使用確認
EXPLAIN SELECT ... WHERE column = value;
-- "Seq Scan" が表示される場合はインデックス未使用
```

---

### Step 4: アプリケーションコード検証

```
Input: バックエンドコード（src/**/*.ts、src/**/*.py）
Task: アンチパターン #19-25 の検出
Constraints:
  - プリペアドステートメント必須
  - パスワードハッシュ必須（bcrypt/Argon2）
  - エラーハンドリング必須（try-catch）
Output:
  - セキュリティリスクレポート（Critical優先）
  - 修正コード例
```

**検証項目**:

1. SQL構築方法を確認（#20 SQLインジェクション）
2. エラーハンドリングを確認（#22 エラー処理欠如）
3. パスワード処理を確認（#19 パスワード平文）
4. 主キー管理を確認（#21 疑似キー潔癖症）

**自動検証コマンド**:

```bash
# SQLインジェクション検出（TypeScript）
grep -rn "\${.*}.*SELECT\|\+.*SELECT" src/
grep -rn "f\"SELECT" src/  # Python f-string

# パスワード平文検出
grep -rn "password.*=.*req.body" src/
```

---

## 自動検証ツール

### 静的解析ツール

```bash
# 1. SQLFluff（SQLリンター）
npm install -g sqlfluff
sqlfluff lint migrations/*.sql --dialect postgres --rules L001,L003,L010

# 2. ESLint + セキュリティプラグイン（TypeScript）
npm install eslint-plugin-security --save-dev
# .eslintrc.js に "plugin:security/recommended" 追加

# 3. Bandit（Pythonセキュリティスキャナー）
pip install bandit
bandit -r src/ -f json -o security-report.json
```

### 動的テスト（PostgreSQL）

```sql
-- pgTAP（PostgreSQLユニットテスト）
BEGIN;
SELECT plan(3);

-- 主キー存在確認
SELECT has_pk('bugs', 'bugsテーブルに主キーがあること');

-- 外部キー整合性確認
SELECT fk_ok('bugs', 'reported_by', 'accounts', 'account_id');

-- NOT NULL制約確認
SELECT col_not_null('bugs', 'bug_id', 'bug_idはNOT NULL');

SELECT * FROM finish();
ROLLBACK;
```

### 継続的監視

```yaml
# GitHub Actions例（.github/workflows/db-lint.yml）
name: Database Lint
on: [pull_request]
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: SQLFluff Lint
        run: |
          pip install sqlfluff
          sqlfluff lint supabase/migrations/*.sql --dialect postgres
      - name: Antipattern Check
        run: |
          bash .agent/scripts/db-antipattern-check.sh
```

---

## レビュー出力フォーマット

### テンプレート1: 重大度順レポート

````markdown
## DBアンチパターンレビュー結果

**実行日時**: 2025-12-11 10:30:00
**対象**: schema.sql, migrations/001_initial.sql
**検出件数**: Critical 2件、High 3件、Medium 5件

---

### 🔴 Critical（即修正必須）

#### #20 SQLインジェクション

- **該当箇所**: `src/api/bugs.ts:45`
- **問題コード**:
  ```typescript
  const query = `SELECT * FROM bugs WHERE bug_id = ${bugId}`; // ❌
  ```
````

- **影響**: 任意のSQLクエリ実行、データ漏洩の可能性
- **修正案**:
  ```typescript
  const query = `SELECT * FROM bugs WHERE bug_id = $1`; // ✅
  const result = await client.query(query, [bugId]);
  ```
- **検証コマンド**: `grep -rn "\${.*}.*SELECT" src/`

#### #19 パスワード平文格納

- **該当箇所**: `schema.sql:12`
- **問題コード**:
  ```sql
  CREATE TABLE accounts (
    password TEXT  -- ❌ 平文
  );
  ```
- **影響**: アカウント情報漏洩時の全ユーザー被害
- **修正案**:
  ```typescript
  // アプリケーション側でハッシュ化
  import bcrypt from "bcrypt";
  const hashedPassword = await bcrypt.hash(password, 10);
  ```
  ```sql
  CREATE TABLE accounts (
    password_hash TEXT NOT NULL  -- ✅ ハッシュ値
  );
  ```

---

### 🟠 High（計画的修正）

#### #9 丸め誤差（FLOAT使用）

- **該当箇所**: `schema.sql:25`
- **問題コード**:
  ```sql
  CREATE TABLE accounts (
    hourly_rate FLOAT  -- ❌
  );
  ```
- **影響**: 金額計算の累積誤差、会計処理の不正確さ
- **修正案**:
  ```sql
  ALTER TABLE accounts
  ALTER COLUMN hourly_rate TYPE NUMERIC(9,2);  -- ✅
  ```
- **検証コマンド**: `grep -n "FLOAT\|DOUBLE" schema.sql`

#### #4 外部キー嫌い

- **該当箇所**: `schema.sql:18`
- **問題コード**:
  ```sql
  CREATE TABLE bugs (
    reported_by BIGINT  -- ❌ 外部キーなし
  );
  ```
- **影響**: 孤立レコード発生、参照整合性違反
- **修正案**:
  ```sql
  ALTER TABLE bugs
  ADD CONSTRAINT fk_reported_by
  FOREIGN KEY (reported_by)
  REFERENCES accounts(account_id)
  ON DELETE SET NULL;  -- ✅
  ```

---

### 🟡 Medium（改善推奨）

（省略：該当する場合のみ記載）

---

### ✅ 問題なしの項目（抜粋）

- ✅ #3 IDリクワイアド: 複合主キーを適切に使用
- ✅ #18 暗黙の列: SELECT文で列名を明示
- ✅ #22 エラー処理: すべてのDBクエリにtry-catch実装

---

### 📊 サマリー

| 重大度   | 検出数 | 修正完了 | 残件  |
| -------- | ------ | -------- | ----- |
| Critical | 2      | 0        | 2     |
| High     | 3      | 1        | 2     |
| Medium   | 5      | 3        | 2     |
| **合計** | **10** | **4**    | **6** |

**推奨対応順序**:

1. Critical 2件（即日対応）
2. High 2件（1週間以内）
3. Medium 2件（次回リファクタリング時）

---

### 🔧 自動検証スクリプト（再現用）

```bash
#!/bin/bash
# db-antipattern-check.sh

echo "=== Critical Check ==="
grep -rn "\${.*}.*SELECT" src/ && echo "❌ SQLインジェクションリスク"
grep -n "password.*TEXT" schema.sql && echo "❌ パスワード平文"

echo "\n=== High Check ==="
grep -n "FLOAT\|DOUBLE" schema.sql && echo "❌ 丸め誤差リスク"
grep -c "FOREIGN KEY" schema.sql || echo "⚠️ 外部キーなし"

echo "\n=== Medium Check ==="
grep -n "SELECT \*" src/**/*.sql && echo "⚠️ 暗黙の列使用"
```

````

### テンプレート2: シンプル版（コードレビュー向け）

```markdown
## アンチパターンチェック結果

✅ **パス**: 5項目
❌ **要修正**: 2件（Critical 1件、High 1件）

### 要修正

1. **#20 SQLインジェクション** (Critical)
   📍 `src/api/bugs.ts:45`
   💡 プリペアドステートメント使用

2. **#9 丸め誤差** (High)
   📍 `schema.sql:25`
   💡 FLOAT → NUMERIC(9,2)に変更
````
