---
trigger: always_on
---

# 技術スタック・UI/UX・ドキュメンテーション指示書

> **📖 関連ドキュメント**
>
> - コアルール: [.copilot-codeGeneration-instructions.md](./.copilot-codeGeneration-instructions.md)
> - アーキテクチャ: [.copilot-architecture.md](./.copilot-architecture.md)

## 1. 採用技術スタック

### 1.1. 技術スタック一覧

| カテゴリ            | 技術                              | 詳細                                                 |
| ------------------- | --------------------------------- | ---------------------------------------------------- |
| **言語**            | TypeScript, Node.js               | 最新LTSバージョン                                    |
| **フレームワーク**  | Next.js, React                    | 最新バージョン、App Router、Server Components活用    |
| **UI**              | Shadcn/UI, Radix UI, Tailwind CSS | Radix UIベースでTailwind CSSでスタイリング           |
| **状態管理**        | Zustand                           | -                                                    |
| **バックエンド/DB** | Supabase                          | 宣言的なスキーマ管理とRLSを徹底                      |
| **ORM**             | Drizzle ORM                       | 最新バージョン                                       |
| **スキーマ検証**    | Zod                               | -                                                    |
| **決済**            | Stripe                            | 一貫した決済フローとWebhook検証を実装                |
| **テスト**          | Vitest, React Testing Library     | UIとロジックを分離したテスト戦略を徹底               |
| **UIカタログ**      | Storybook                         | アクセシビリティ検証も含めたカタログ運用             |
| **API**             | Hono                              | 最新バージョン、Node.jsバックエンドで高速なAPIを提供 |
| **その他/ツール**   | nuqs                              | URLパラメーターによる状態同期に活用                  |

### 1.2. バージョン方針

- **常に最新:** React、Next.js は常に最新バージョンを使用
- **LTS:** Node.js は最新LTSバージョンを使用
- **安定版:** その他のライブラリも最新の安定版を使用

---

## 2. UI/UX とアクセシビリティ

### 2.1. UI/UX 基本方針

| 原則                               | 詳細                                                             |
| ---------------------------------- | ---------------------------------------------------------------- |
| **直感的なデザイン**               | ユーザーインターフェースは直感的で使いやすく設計                 |
| **レスポンシブデザイン**           | 様々なデバイス (PC、タブレット、スマートフォン) での表示を最適化 |
| **アニメーションとトランジション** | ユーザー体験を向上させるために、適切かつ効果的に使用             |
| **タグ入力の補完**                 | 一度入力したタグは、次回入力時に補完される                       |

### 2.2. アクセシビリティ

| 項目               | 要件                                                                                                                          |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------- |
| **キーボード操作** | 全てのインタラクティブな要素がキーボードのみで操作できる                                                                      |
| **ARIA属性と役割** | コンポーネントに適切なARIA (Accessible Rich Internet Applications) ラベルと役割を実装し、支援技術による情報の伝達を正確にする |
| **コントラスト比** | 色のコントラスト比がWCAG (Web Content Accessibility Guidelines) の基準を満たす                                                |

---

## 3. 採用技術スタックの詳細な活用方針

### 3.1. Next.js と React

| 項目                  | 方針                                                                     |
| --------------------- | ------------------------------------------------------------------------ |
| **バージョン**        | 常に最新バージョンのReactとNext.jsを使用                                 |
| **App Router**        | Next.js App Routerを積極的に活用                                         |
| **Server Components** | Server Componentsを活用し、パフォーマンスの高いWebアプリケーションを構築 |

### 3.2. Hono (API)

APIの実装には、軽量で高速なWebフレームワークであるHonoを使用します。

| 項目                 | 方針                                                                               |
| -------------------- | ---------------------------------------------------------------------------------- |
| **ルーティング**     | シンプルかつ直感的に記述                                                           |
| **ミドルウェア**     | 認証やエラーハンドリングなどの共通処理は、Honoのミドルウェアを活用して効率的に実装 |
| **型安全性**         | TypeScriptの型定義を適切に使用し、型安全なAPI開発を徹底                            |
| **エコシステム活用** | 必要に応じて、Honoの提供するエコシステム (例: `hono/jwt`, `hono/cors`) を活用      |

### 3.3. Next.js サーバーアクション

Next.jsのサーバーアクションを積極的に使用します。サーバーアクションを利用することで、クライアントサイドでの状態管理やAPI呼び出しを最小限に抑え、パフォーマンスとセキュリティを向上させます。

| 項目                   | 方針                                                                             |
| ---------------------- | -------------------------------------------------------------------------------- |
| **入力バリデーション** | 入力データのバリデーションにはZodを使用                                          |
| **エラー処理**         | 適切なエラー処理を実装し、ユーザーに分かりやすいエラーメッセージを提供           |
| **戻り値のモデル化**   | サーバーアクションの戻り値として、成功時とエラー時の両方のケースを明確にモデル化 |

---

## 4. ドキュメンテーション

### 4.1. ドキュメンテーション要件

| 種別               | 要件                                                                                                                                                        |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **コメント**       | 複雑なロジックや理解が難しい箇所には、明確で簡潔なコメントを記述                                                                                            |
| **TSDoc**          | エクスポートされる関数やコンポーネントにはTSDoc形式のコメントを使用し、IDEのインテリセンス (入力補完やヒント表示) を向上させる                              |
| **READMEファイル** | プロジェクトのREADMEファイルは常に最新の状態に保ち、セットアップ手順、プロジェクトの概要、主要な機能について記載                                            |
| **Supabase関連**   | Supabaseのスキーマ定義、RLS (Row Level Security) ポリシー、およびEdge関数やStripe Webhook設定を使用する場合は、それらの設計や意図に関するドキュメントを作成 |

### 4.2. TSDoc の記述例

````typescript
/**
 * ユーザープロファイルを取得する
 *
 * @param userId - 取得対象のユーザーID
 * @returns ユーザープロファイル情報、または失敗時はエラー
 *
 * @example
 * ```typescript
 * const result = await getUserProfile({ userId: "user_123" });
 * if (result.isOk()) {
 *   console.log(result.value);
 * }
 * ```
 *
 * @remarks
 * - 実DBを用いた結合テストで検証済み
 * - キャッシュは5分間有効
 */
export const getUserProfile = async ({ userId }: { userId: string }) => {
  // ...
};
````

---

## 5. 技術選定の原則

### 5.1. ライブラリ選定基準

新しいライブラリを導入する際は、以下の基準を満たすことを確認してください：

| 基準                   | 詳細                                                                   |
| ---------------------- | ---------------------------------------------------------------------- |
| **メンテナンス状態**   | アクティブにメンテナンスされている                                     |
| **TypeScript対応**     | TypeScriptの型定義が提供されている、または @types パッケージが存在する |
| **コミュニティサイズ** | 十分なコミュニティサイズと実績がある                                   |
| **ライセンス**         | プロジェクトで使用可能なライセンス（MIT、Apache 2.0など）              |
| **バンドルサイズ**     | パフォーマンスへの影響が許容範囲内                                     |
| **既存技術との整合性** | 既存の技術スタックと整合性が取れている                                 |

### 5.2. 技術スタック変更時の手順

1. **提案:** 変更理由と代替技術を明確に記載
2. **検証:** 小規模な検証環境で動作確認
3. **ドキュメント更新:** 本ファイルと関連ドキュメントを更新
4. **移行計画:** 段階的な移行計画を策定（必要に応じて）
5. **チームレビュー:** チーム全体でレビューと承認

---

## 6. パフォーマンス最適化

### 6.1. Next.js パフォーマンス最適化

| 項目                  | 方針                                                                     |
| --------------------- | ------------------------------------------------------------------------ |
| **Server Components** | デフォルトでServer Componentsを使用し、必要な場合のみClient Components化 |
| **画像最適化**        | Next.js の Image コンポーネントを使用し、自動最適化を活用                |
| **フォント最適化**    | Next.js の Font Optimization を使用                                      |
| **バンドルサイズ**    | Dynamic Import を活用し、初期バンドルサイズを最小化                      |
| **キャッシング**      | ISR (Incremental Static Regeneration) や revalidate を適切に設定         |

### 6.2. 測定と監視

| 項目                   | ツール/方法                             |
| ---------------------- | --------------------------------------- |
| **Core Web Vitals**    | Lighthouse、Web Vitals ライブラリで測定 |
| **バンドルサイズ分析** | @next/bundle-analyzer を使用            |
| **パフォーマンス監視** | Vercel Analytics または同等のツール     |

---
