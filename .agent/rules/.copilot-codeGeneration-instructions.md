---
trigger: always_on
---

# コード生成指示書

## 1. はじめに

### 1.1. このファイルの役割

このファイルは、コードを生成する際の指示を提供し、プロジェクト全体の一貫性と品質を維持することを目的とします。

### 1.2. エキスパートとしての振る舞い

- **言語:** TypeScript, Node.js (最新LTSバージョン)
- **フレームワーク/ライブラリ:** Next.js (最新バージョン、App Router、Server Components活用), React (最新バージョン)
- **UI:** Shadcn/UI, Radix UI, Tailwind CSS (Radix UIベースでTailwind CSSでスタイリング)
- **状態管理:** Zustand
- **バックエンド/DB:** Supabase を採用し、宣言的なスキーマ管理とRLSを徹底します。
- **ORM:** Drizzle ORM (最新バージョン)
- **スキーマ検証:** Zod
- **決済:** Stripe（一貫した決済フローとWebhook検証を実装）
- **テスト:** Vitest, React Testing Library（UIとロジックを分離したテスト戦略を徹底）
- **UI コンポーネント開発/管理:** Storybook（アクセシビリティ検証も含めたカタログ運用）
- **API:** Hono (最新バージョン、Node.jsバックエンドで高速なAPIを提供)
- **その他/ツール:** nuqs（URLパラメーターによる状態同期に活用）

## 2. AIコーディング規範

### 目的

AIは、本規範に厳格に従い、**不変性、予測可能性、そして完全なテスト容易性**を確保したコードを生成すること。例外処理は型システムで強制し、ランタイムエラーの発生を最小限に抑える。

### 2.1. 構造とモジュール化のルール (Modularity & Architecture)

| No.     | 必須ルール              | 詳細（AIへの指示）                                                                                                                                        |
| :------ | :---------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **I-1** | **テストの最重要性**    | **結合テスト**が最も重要であり、全ての機能は厳格なテストの下で実装されること。                                                                            |
| **I-2** | **インポート管理**      | `require` および 一般的な `import` 文は禁止。必ず **`import` 宣言**を使用し、eslint-plugin-boundariesに従い、ディレクトリのインポート方向を強制すること。 |
| **I-3** | **サブパス禁止**        | `import "hoge/sub"` のような深い階層のサブパス import は禁止。常に公開されたパスからインポートすること。                                                  |
| **I-4** | **Barrel Export 厳守**  | 各ディレクトリには必ず **`index.ts`** ファイルを設置し、そのレイヤーで公開してよいものだけを export すること。                                            |
| **I-5** | **Index.ts の純粋性**   | `index.ts` は **re-export 以外**のロジック（関数定義など）を記述してはならない。                                                                          |
| **I-6** | **Default Export 禁止** | `export default` は使用せず、全て **名前付きエクスポート (Named Export)** を使用すること。                                                                |

### 2.2. 機能とデータ処理のルール (Functional & Data Flow)

| No.       | 必須ルール                         | 詳細（AIへの指示）                                                                                                                                                                                                                                                                      |
| :-------- | :--------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **II-1**  | **クラス禁止**                     | `class` の定義は原則禁止。互換性維持など、どうしても必要な場合のみ例外的に許可する。                                                                                                                                                                                                    |
| **II-2**  | **Enum 禁止**                      | `enum` は絶対に使用しないこと。                                                                                                                                                                                                                                                         |
| **II-3**  | **完全な不変性**                   | 変数の再代入を防ぐため、**`let` の使用を禁止**し、全ての変数を `const` で宣言すること。オブジェクトや配列の型には必ず **`readonly`** を付与し、不変性を強制すること。                                                                                                                   |
| **II-4**  | **Argument Object 強制**           | 関数の引数が 2 つ以上になる場合、必ず **単一のオブジェクト（名前付き引数パターン）**として渡すこと。                                                                                                                                                                                    |
| **II-5**  | **シャドーイング禁止**             | スコープ外の変数と同じ名前の変数を、内側のスコープで宣言すること（シャドーイング）を禁止する。                                                                                                                                                                                          |
| **II-6**  | **マジックバリュー禁止**           | コード内に直接、意味の不明瞭な数値や文字列（マジックナンバー、マジックストリング）を記述することを禁止。必ず `const` 定義すること。                                                                                                                                                     |
| **II-7**  | **配列操作の不変性保証**           | 配列を操作する際は、必ず元の配列をコピーしてから操作すること。`[...array]` や `Array.from()` でコピー。`.map()`, `.filter()`, `.reduce()` など新しい配列を返すメソッドを推奨。`.sort()`, `.reverse()`, `.push()`, `.pop()` などの破壊的メソッドを元の配列に直接適用することを禁止する。 |
| **II-8**  | **Optional Chaining の積極的使用** | 配列やオブジェクトのプロパティアクセス時は、可能な限り Optional Chaining (`?.`) を使用すること。`null` / `undefined` チェックを明示的に行う代わりに、`?.` で安全にアクセスする。                                                                                                        |
| **II-9**  | **型定義の明確化**                 | 限定された値の集合を表現する場合、`enum` ではなく Union Types を使用すること。複雑な型や再利用される型は `type` で定義。リテラル型を保証する場合は `as const` を使用すること。例: `type SortOrder = "asc" \| "desc";`                                                                   |
| **II-10** | **国際化対応**                     | `localeCompare` などのロケール依存処理で、ロケール文字列（`"ja"`, `"en"` など）を直接記述することを禁止。ロケールは環境変数または定数ファイルで一元管理すること。例: `const LOCALE = "ja" as const;`                                                                                    |

### 2.3. エラーと非同期処理のルール (Error Handling & Types)

| No.       | 必須ルール             | 詳細（AIへの指示）                                                                                                             |
| :-------- | :--------------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| **III-1** | **Throw 禁止**         | 例外を発生させる `throw` 文は禁止。                                                                                            |
| **III-2** | **Try/Catch 禁止**     | `try / catch` の使用は、外部システムとの境界（腐敗防止層）でのみ許可し、それ以外のレイヤーでは禁止する。                       |
| **III-3** | **非同期処理の型**     | `Promise` を直接返さず、必ず **`ResultAsync`** のような Result 型に寄せて、成功/失敗の結果を型で明示すること。                 |
| **III-4** | **Zod safeParse 強制** | Zod ライブラリを使用する際、検証メソッドは `parse` ではなく、必ず **`safeParse`** を使用すること。                             |
| **III-5** | **型アサーション禁止** | `as` や `!` (非 null アサーション) を使用した型アサーションを禁止する。必ず型ガード関数や適切なチェックで型を絞り込むこと。    |
| **III-6** | **ネストの制限**       | 制御フロー（`if`, `for`, `while` など）のネストは深さ **1** までとし、早期リターン（ガード節）を用いてコードを平坦に保つこと。 |

### 2.4. AI運用とテスト・品質ガード（Operational & AI-specific rules）

| No.      | 必須ルール                                             | 詳細（AIへの指示）                                                                                                                                                                                                                                     |
| :------- | :----------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **IV-1** | **暗黙のフォールバック禁止 (No implicit fallback)**    | LLM による勝手な補完・暗黙のフォールバックを禁止します。欠損値や想定外の状態については、必ず明示的に失敗を返す（Result 型等）か、仕様として事前に定義されたフォールバックを適用してテストで検証してください。                                          |
| **IV-2** | **ダミー/NO-OP 実装の禁止 (No mocking in production)** | プロダクション用コード内での NO-OP / ダミー実装を禁止します。テストでモックを使う場合でも、必ず"実 DB を用いた結合テスト"を作成し、モックのみで成功するケースを許容しないこと。                                                                        |
| **IV-3** | **fail-fast の条件付き適用**                           | `fail-fast` を無条件に適用することを禁止します。fail-fast を採用する場合はリスク評価と回復戦略（リトライ、代替処理、監視/アラート）を明文化し、該当箇所を限定（例: 腐敗防止層）してテストで検証すること。                                              |
| **IV-4** | **結合テスト重視・サーバー側実DB使用・カバレッジ目標** | サーバー側 API/Repository は「実 DB を用いた結合テスト」を必須とし、サーバー側コードのカバレッジは **100% を目標** とする（現実的制約がある場合は CI によるフル結合テストの夜間実行等の補完を許可）。                                                  |
| **IV-5** | **TSDoc の厳格化**                                     | 公開 API、Repository メソッド、Server Actions、複雑な関数には必ず TSDoc を記述し、`目的 (purpose)`, `内容 (params/returns)`, `注意事項 (remarks)` を必須化する。日本語で記載し、@example を用いて使い方を示すこと。                                    |
| **IV-6** | **CI と linter による自動阻止**                        | 上記ルールは文書化するだけでなく、CI と linter（ESLint + 各種プラグイン）で自動検出・阻止できる仕組みを必ず導入すること。PR マージ前にルール違反がある場合はブロックされるように設定する（TSDoc 必須チェック、禁止構文の検出、カバレッジゲートなど）。 |

**運用メモ**:

- ルールは必ず CI と lint で守らせる。単にルールを書くだけでは不十分。
- テスト用モックは許されるが、その場合でも「モックでのみグリーンになるテスト」を許さず、実 DB を利用した結合テストを同等レベルで確保すること。

### 2.5. 命名規則

- **PascalCase:** コンポーネント名、インターフェース、型エイリアス。
- **camelCase:** 変数、関数、メソッド。
- **アンダースコアプレフィックス (`_`):** プライベートなクラスメンバー（クラスの使用は原則避けるため、適用場面は限定的です）。
- **ALL_CAPS:** 定数。
- **意味のある名前:** 変数名や関数名など、全ての命名においてその役割や目的が明確に分かるように、具体的かつ説明的な名前を選んでください。
- **補助動詞:** `isLoading`, `hasError` のように、状態を表す変数は補助動詞を用いて説明的にします。

### 2.6. TDD実行手順（AIへの依頼）

AIは、選択した**細分化タスク**を完了させるため、以下のRGRサイクルを順に実行すること。

#### テストファイル命名規則

view関連のテストファイル名

\_.test.tsx

ビジネスロジックやfetchのテストファイル名
\_.test.ts

- テストファイルは、テストするコンポーネントやロジックと同じディレクトリに配置し、関連性を明確にします。

#### テスト記述規約

- **テストフレームワーク**: Vitest + React Testing Library を使用
- **テスト構造**: `describe` でコンポーネント/関数名、`it` で具体的な振る舞いを記述
- **日本語記述**: テストケース名は日本語で記述し、仕様を明確にする
- **AAA パターン**: Arrange（準備）、Act（実行）、Assert（検証）を明確に分ける
- **例**:
  ```typescript
  describe("ProfileList", () => {
    it("名前を表示する", () => {
      // Arrange
      const props = { name: "山田太郎", role: "エンジニア", bio: "開発者" };

      // Act
      render(<ProfileList {...props} />);

      // Assert
      expect(screen.getByText("山田太郎")).toBeInTheDocument();
    });
  });
  ```

##### 🔴 ステップ1: テストコードの生成（REDフェーズ）

1.  タスクの要件を満たすための**失敗するテストコード**を、該当する**テストファイル**（例: `[ComponentName].test.tsx`）に記述する。
2.  テストを実行し、**失敗（RED）すること**を確認する。

##### 🟢 ステップ2: アプリケーションコードの生成（GREENフェーズ）

1.  ステップ1で生成したテストを**すべて合格させる**ための**最小限のアプリケーションコード**を、対応するファイルに記述する。
2.  テストを再度実行し、\*\*すべてがグリーン（合格）\*\*になることを確認する。

##### ✨ ステップ3: リファクタリング（REFACTORフェーズ）

1.  テストがグリーンであることを前提に、生成したコードに対して**品質、可読性、効率**を高めるためのリファクタリングを提案・実行する。
2.  リファクタリング後、**テストが引き続きグリーン**であることを最終確認し、\*\*タスクを完了（チェック）\*\*とする。

### 2.7. コード生成の基本方針

- **レビューと理解:** コードを記述する前に、既存のコードを深くレビューし、その動作を正確に理解します。
- **簡潔性と正確性:** 正確な例を用い、簡潔で技術的に正しいTypeScriptコードを記述します。
- **宣言的なJSX:** 読みやすく、意図が明確な宣言的なJSXを記述します。
- **関数型・宣言型プログラミング:** 関数型および宣言型のプログラミングパターンを優先し、クラスベースの実装は避けます。
- **ROROパターン (Receive an Object, Return an Object):** 必要に応じて、オブジェクトを受け取り、オブジェクトを返すROROパターンを使用します。
- **ファイル構成要素:** エクスポートされるコンポーネント、サブコンポーネント、ヘルパー関数、静的コンテンツ、型定義などでファイルを構成します。
- **ファイルサイズ:** 1ファイルの行数は500行以内を目安とし、これを超える場合は適切にファイルを分割します。
- **コンポーネントのエクスポート:** コンポーネントは名前付きエクスポート (`export const MyComponent = ...`) を使用します。

### 2.8. ファイル・ディレクトリ構成

重要: このプロジェクトでは「ルーティング（ページ）」と「コンポーネント（UI/ビジネスロジック）」を明確に分離し、さらにコンポーネントごとに責務を分けることで可読性とテスト容易性を高めます。以下は Qiita 記事の実践例に基づく具体ルールです。

1. ルーティングとコンポーネントの分離

- ルート（ページ）は `app/<route>/page.tsx` や `layout.tsx` に限定しておき、ページ内では「どのコンポーネントを並べるか」を責務とします。
- ページ (`app/<route>/page.tsx` / `layout.tsx`) は可能な限り副作用（データ取得）を持たず、表示とコンポーネントの組み立てに専念します。データの取得（フェッチ）は各機能・コンポーネント配下の `*.fetch.ts`（または同等の hook）に配置する方針です。

2. コンポーネントはフォルダ単位で分離し、責務別ファイルを配置（コロケーション）

- 各コンポーネントは独立したフォルダにし、UI・ロジック・fetch・テストを分割します。例:

  src/components/route1/component-a/
  ├─ component-a.tsx # プレゼンテーション（UI） — 可能なら client component に限定
  ├─ component-a.logic.ts # コンポーネント固有のビジネスロジック／ユーティリティ
  ├─ component-a.fetch.ts # フェッチ（副作用）を機能として配置。API 呼び出しやデータ取得フローをここに集約する
  └─ component-a.test.ts # component-a に関するテスト（UIとロジック）

- コロケーションの利点: 関連ファイルがまとまっているため、変更範囲が分かりやすく、Agent による自動生成やテスト作成が容易になります。

3. ページ専用のコンポーネントまとめと index.ts の活用

- ページ単位で使うコンポーネント群は `src/components/<route>/index.ts` で名前付きエクスポートし、ページ側でネームスペースインポートします。

  // src/components/route1/index.ts
  // コンポーネントファイルは名前付きエクスポートを前提とする（推奨）
  // 例: ComponentA.tsx に `export const ComponentA = (...)` と定義します。
  export { ComponentA } from "@/components/route1/ComponentA/ComponentA";
  export { ComponentB } from "@/components/route1/ComponentB/ComponentB";

  // app/route1/page.tsx
  // ネームスペースインポート（import _ as）を使用
  import _ as route1 from '@/components/route1';

  export default function Route1Page() {
  return (
  <>
  <route1.ComponentA />
  <route1.ComponentB />
  </>
  );
  }

4. データフェッチの明確化

- 大きなデータフェッチ（ページ全体のリソース取得）は可能な限り機能単位の `components/<feature>/*.fetch.ts` に配置し、ページ（ルーティング）は表示とコンポーネントの組み立てに専念します。例外的にページ側で集約フェッチが必要な場合のみ `page.tsx` に置くことを許容します。
- 小さく独立したデータは `component-x.fetch.ts` のようにコンポーネント隣接ファイルで定義し、必要なときに注入して使います。ただし可能な限り props 経由での受け渡しを推奨します。
- Server Actions を使って整合性のあるサーバ呼び出しを行うパターンも許容（ただし責務はページ側でまとめること）。

5. 命名とエクスポート方針

- コンポーネントはデフォルトエクスポートせず、名前付きエクスポートを推奨（index.ts で集約した際に扱いやすいため）。
- フォルダ名とファイル名は一致させ、パス解決を簡潔にすること。

6. テストの分離

- UI のテストは ComponentA.tsx に対して行い、ビジネスロジックや fetch はそれぞれのファイルでユニットテストを分ける。これによりテスト設計が簡潔になります。
- **ディレクトリ名:** ケバブケース (例: `components/personal-information`) を使用します。
- **ページ固有のデータフェッチ:**
- **場所:** 原則として `components/**/*.fetch.ts` に置き、ページ (`page.tsx` / `layout.tsx`) はフェッチを持たない（表示・組み立て専念）。
- **理由:** フェッチをコンポーネント配下に置くことで、機能単位で副作用が完結し、テストやモックが容易になるため。例外的にページレベルで集約が必要なら page に置けますが推奨しません。
- **コンポーネント固有のデータフェッチ:**
  - **場所:** `component-a.fetch.ts` のようなデータ取得専用ファイル（または専用 hook）を推奨します。`component-a.logic.ts` はデータの変換や UI に渡すための純粋ロジックを置く目的で使います。
  - **理由:** データ取得（副作用）を専用ファイルに切り出すことで、テストでのモックや再利用が容易になり、ビジネスロジック（logic）と副作用（fetch）が明確に分離されます。
- **具体的な構成例:**
  ```
  app/
    [page-name]/
      layout.tsx         // ページのレイアウトコンポーネント
      page.tsx           // ページコンポーネント（副作用は持たず表示に専念）
      common/            // 共通コンポーネントを格納するフォルダ
        common-component.tsx
        common-component.logic.ts
        common-component.test.ts
      components/        // ページ固有のコンポーネントを格納するフォルダ
        component-a.tsx
        component-a.logic.ts
        component-a.test.ts
        component-b.tsx
        component-b.logic.ts
        component-b.test.ts
      utils/             // (必要に応じてユーティリティ関数などを格納)
        helper-functions.ts
      [page-name].test.tsx        // ページコンポーネントのテストファイル (任意)
  ```

### 2.9. Supabase / Drizzle の命名規約

- **公式ルール:** Supabase は Postgres を基盤としており、データベース識別子（データベース名・スキーマ名・テーブル名など）は [PostgreSQL の識別子仕様](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) に準拠します。未引用識別子は 63 文字以内で、アルファベットまたはアンダースコアで開始し、英数字もしくはアンダースコアのみを含めます。引用識別子は例外ですが、生成コードでは使用しません。
- **運用方針:** Drizzle の `casing: 'snake_case'` 構成を利用し、テーブル・カラムは `snake_case` で統一します（参考: [Drizzle ドキュメント](https://orm.drizzle.team/docs/sql-schema-declaration#camel-and-snake-casing)）。
- **命名ガード:** データベース名、スキーマ名、テーブル名、カラム名、インデックス名など全識別子は 63 文字以内で明確な意味を持たせ、略語は最低限に留めます。
- **Drizzle スキーマ:** Supabase の宣言的スキーマと整合するように、Drizzle の `pgTable` 定義は Supabase マイグレーションと同一ソース（例: `src/db/schema/*.ts`）を真実の源泉とし、マイグレーション生成前に命名を自動検証します。

## 3. UI/UX とアクセシビリティ

### 3.1. UI/UX 基本方針

- **直感的なデザイン:** ユーザーインターフェースは直感的で使いやすく設計します。
- **レスポンシブデザイン:** 様々なデバイス (PC、タブレット、スマートフォン) での表示を最適化するため、レスポンシブデザインを採用します。
- **アニメーションとトランジション:** ユーザー体験を向上させるために、アニメーションやトランジションを適切かつ効果的に使用します。
- **タグ入力の補完:** 一度入力したタグは、次回入力時に補完されるようにします。

### 3.2. アクセシビリティ

- **キーボード操作:** 全てのインタラクティブな要素がキーボードのみで操作できるようにします。
- **ARIA属性と役割:** コンポーネントに適切なARIA (Accessible Rich Internet Applications) ラベルと役割を実装し、支援技術による情報の伝達を正確にします。
- **コントラスト比:** 色のコントラスト比がWCAG (Web Content Accessibility Guidelines) の基準を満たしていることを確認し、視覚障碍のあるユーザーにも配慮します。

## 4. 採用技術スタックと詳細な活用方針

### 4.1. Next.js と React

- 常に最新バージョンのReactとNext.jsを使用します。
- Next.js App RouterのServer Componentsを積極的に活用し、パフォーマンスの高いWebアプリケーションを構築します。

### 4.2. Hono (API)

- APIの実装には、軽量で高速なWebフレームワークであるHonoを使用します。
- **ルーティング:** シンプルかつ直感的に記述します。
- **ミドルウェア:** 認証やエラーハンドリングなどの共通処理は、Honoのミドルウェアを活用して効率的に実装します。
- **型安全性:** TypeScriptの型定義を適切に使用し、型安全なAPI開発を徹底します。
- **エコシステム活用:** 必要に応じて、Honoの提供するエコシステム (例: `hono/jwt`, `hono/cors`) を活用します。

### 4.3. Next.js サーバーアクション

- Next.jsのサーバーアクションを積極的に使用します。
- サーバーアクションを利用することで、クライアントサイドでの状態管理やAPI呼び出しを最小限に抑え、パフォーマンスとセキュリティを向上させます。
- **入力バリデーション:** 入力データのバリデーションにはZodを使用します。
- **エラー処理:** 適切なエラー処理を実装し、ユーザーに分かりやすいエラーメッセージを提供します。
- **戻り値のモデル化:** サーバーアクションの戻り値として、成功時とエラー時の両方のケースを明確にモデル化します。

## 5. ドキュメンテーション

- **コメント:** 複雑なロジックや理解が難しい箇所には、明確で簡潔なコメントを記述します。
- **TSDoc:** IDEのインテリセンス (入力補完やヒント表示) を向上させるため、エクスポートされる関数やコンポーネントにはTSDoc形式のコメントを使用します。
- **READMEファイル:** プロジェクトのREADMEファイルは常に最新の状態に保ち、セットアップ手順、プロジェクトの概要、主要な機能について記載します。
- **Supabase関連ドキュメント:** Supabaseのスキーマ定義、RLS (Row Level Security) ポリシー、およびEdge関数やStripe Webhook設定を使用する場合は、それらの設計や意図に関するドキュメントを作成します。

---
