---
trigger: always_on
---

# コード生成指示書

## 1. はじめに

### 1.1. このファイルの役割

このファイルは、コードを生成する際の指示を提供し、プロジェクト全体の一貫性と品質を維持することを目的とします。

### 1.2. エキスパートとしての振る舞い

以下の技術スタックに精通したエキスパートとして振る舞ってください。

- **言語:** TypeScript, Node.js (最新LTSバージョン)
- **フレームワーク/ライブラリ:** Next.js (最新バージョン、App Router、Server Components活用), React (最新バージョン)
- **UI:** Shadcn/UI, Radix UI, Tailwind CSS (Radix UIベースでTailwind CSSでスタイリング)
- **状態管理:** Zustand
- **バックエンド/DB:** Supabase を採用し、宣言的なスキーマ管理とRLSを徹底します。
- **ORM:** Drizzle ORM (最新バージョン)
- **スキーマ検証:** Zod
- **決済:** Stripe（一貫した決済フローとWebhook検証を実装）
- **テスト:** Vitest, React Testing Library（UIとロジックを分離したテスト戦略を徹底）
- **UI コンポーネント開発/管理:** Storybook（アクセシビリティ検証も含めたカタログ運用）
- **API:** Hono (最新バージョン、Node.jsバックエンドで高速なAPIを提供)
- **その他/ツール:** nuqs（URLパラメーターによる状態同期に活用）

## 2. プロジェクト全体のコーディング規約

### 2.1. 命名規則

- **PascalCase:** コンポーネント名、インターフェース、型エイリアス。
- **camelCase:** 変数、関数、メソッド。
- **アンダースコアプレフィックス (`_`):** プライベートなクラスメンバー（クラスの使用は原則避けるため、適用場面は限定的です）。
- **ALL_CAPS:** 定数。
- **意味のある名前:** 変数名や関数名など、全ての命名においてその役割や目的が明確に分かるように、具体的かつ説明的な名前を選んでください。
- **補助動詞:** `isLoading`, `hasError` のように、状態を表す変数は補助動詞を用いて説明的にします。

### 2.2. エラーハンドリング

- **try/catchブロック:** 非同期処理 (`async/await`) では `try/catch` ブロックを使用してエラーを捕捉します。
- **エラー境界 (Error Boundaries):** Reactコンポーネントにおいて適切なエラー境界を実装し、UIの一部で発生したエラーがアプリケーション全体に影響を与えないようにします。
- **エラーログ:** エラー発生時には、問題の特定と解決を助けるために、発生箇所や状況がわかるコンテキスト情報を含めてエラーログを記録します。

### 2.3. コード生成の基本方針

- **レビューと理解:** コードを記述する前に、既存のコードを深くレビューし、その動作を正確に理解します。
- **簡潔性と正確性:** 正確な例を用い、簡潔で技術的に正しいTypeScriptコードを記述します。
- **宣言的なJSX:** 読みやすく、意図が明確な宣言的なJSXを記述します。
- **関数型・宣言型プログラミング:** 関数型および宣言型のプログラミングパターンを優先し、クラスベースの実装は避けます。
- **ROROパターン (Receive an Object, Return an Object):** 必要に応じて、オブジェクトを受け取り、オブジェクトを返すROROパターンを使用します。
- **ファイル構成要素:** エクスポートされるコンポーネント、サブコンポーネント、ヘルパー関数、静的コンテンツ、型定義などでファイルを構成します。
- **ファイルサイズ:** 1ファイルの行数は500行以内を目安とし、これを超える場合は適切にファイルを分割します。
- **コンポーネントのエクスポート:** コンポーネントは名前付きエクスポート (`export const MyComponent = ...`) を使用します。

### 2.4. ファイル・ディレクトリ構成

重要: このプロジェクトでは「ルーティング（ページ）」と「コンポーネント（UI/ビジネスロジック）」を明確に分離し、さらにコンポーネントごとに責務を分けることで可読性とテスト容易性を高めます。以下は Qiita 記事の実践例に基づく具体ルールです。

1. ルーティングとコンポーネントの分離

- ルート（ページ）は `app/<route>/page.tsx` や `layout.tsx` に限定しておき、ページ内では「どのコンポーネントを並べるか」を責務とします。
- ページ (`app/<route>/page.tsx` / `layout.tsx`) は可能な限り副作用（データ取得）を持たず、表示とコンポーネントの組み立てに専念します。データの取得（フェッチ）は各機能・コンポーネント配下の `*.fetch.ts`（または同等の hook）に配置する方針です。

2. コンポーネントはフォルダ単位で分離し、責務別ファイルを配置（コロケーション）

- 各コンポーネントは独立したフォルダにし、UI・ロジック・fetch・テストを分割します。例:

  src/components/route1/component-a/
  ├─ component-a.tsx # プレゼンテーション（UI） — 可能なら client component に限定
  ├─ component-a.logic.ts # コンポーネント固有のビジネスロジック／ユーティリティ
  ├─ component-a.fetch.ts # フェッチ（副作用）を機能として配置。API 呼び出しやデータ取得フローをここに集約する
  └─ component-a.test.ts # component-a に関するテスト（UIとロジック）

- コロケーションの利点: 関連ファイルがまとまっているため、変更範囲が分かりやすく、Agent による自動生成やテスト作成が容易になります。

3. ページ専用のコンポーネントまとめと index.ts の活用

- ページ単位で使うコンポーネント群は `src/components/<route>/index.ts` で名前付きエクスポートし、ページ側でネームスペースインポートします。

  // src/components/route1/index.ts
  // コンポーネントファイルは名前付きエクスポートを前提とする（推奨）
  // 例: ComponentA.tsx に `export const ComponentA = (...)` と定義します。
  export { ComponentA } from "@/components/route1/ComponentA/ComponentA";
  export { ComponentB } from "@/components/route1/ComponentB/ComponentB";

  // app/route1/page.tsx
  // ネームスペースインポート（import _ as）を使用
  import _ as route1 from '@/components/route1';

  export default function Route1Page() {
  return (
  <>
  <route1.ComponentA />
  <route1.ComponentB />
  </>
  );
  }

4. データフェッチの明確化

- 大きなデータフェッチ（ページ全体のリソース取得）は可能な限り機能単位の `components/<feature>/*.fetch.ts` に配置し、ページ（ルーティング）は表示とコンポーネントの組み立てに専念します。例外的にページ側で集約フェッチが必要な場合のみ `page.tsx` に置くことを許容します。
- 小さく独立したデータは `component-x.fetch.ts` のようにコンポーネント隣接ファイルで定義し、必要なときに注入して使います。ただし可能な限り props 経由での受け渡しを推奨します。
- Server Actions を使って整合性のあるサーバ呼び出しを行うパターンも許容（ただし責務はページ側でまとめること）。

5. 命名とエクスポート方針

- コンポーネントはデフォルトエクスポートせず、名前付きエクスポートを推奨（index.ts で集約した際に扱いやすいため）。
- フォルダ名とファイル名は一致させ、パス解決を簡潔にすること。

6. テストの分離

- UI のテストは ComponentA.tsx に対して行い、ビジネスロジックや fetch はそれぞれのファイルでユニットテストを分ける。これによりテスト設計が簡潔になります。
- **ディレクトリ名:** ケバブケース (例: `components/personal-information`) を使用します。
- **ページ固有のデータフェッチ:**
- **場所:** 原則として `components/**/*.fetch.ts` に置き、ページ (`page.tsx` / `layout.tsx`) はフェッチを持たない（表示・組み立て専念）。
- **理由:** フェッチをコンポーネント配下に置くことで、機能単位で副作用が完結し、テストやモックが容易になるため。例外的にページレベルで集約が必要なら page に置けますが推奨しません。
- **コンポーネント固有のデータフェッチ:**
  - **場所:** `component-a.fetch.ts` のようなデータ取得専用ファイル（または専用 hook）を推奨します。`component-a.logic.ts` はデータの変換や UI に渡すための純粋ロジックを置く目的で使います。
  - **理由:** データ取得（副作用）を専用ファイルに切り出すことで、テストでのモックや再利用が容易になり、ビジネスロジック（logic）と副作用（fetch）が明確に分離されます。
- **具体的な構成例:**
  ```
  app/
    [page-name]/
      layout.tsx         // ページのレイアウトコンポーネント
      page.tsx           // ページコンポーネント（副作用は持たず表示に専念）
      common/            // 共通コンポーネントを格納するフォルダ
        common-component.tsx
        common-component.logic.ts
        common-component.test.ts
      components/        // ページ固有のコンポーネントを格納するフォルダ
        component-a.tsx
        component-a.logic.ts
        component-a.test.ts
        component-b.tsx
        component-b.logic.ts
        component-b.test.ts
      utils/             // (必要に応じてユーティリティ関数などを格納)
        helper-functions.ts
      [page-name].test.tsx        // ページコンポーネントのテストファイル (任意)
  ```

### 2.5. Supabase / Drizzle の命名規約

- **公式ルール:** Supabase は Postgres を基盤としており、データベース識別子（データベース名・スキーマ名・テーブル名など）は [PostgreSQL の識別子仕様](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) に準拠します。未引用識別子は 63 文字以内で、アルファベットまたはアンダースコアで開始し、英数字もしくはアンダースコアのみを含めます。引用識別子は例外ですが、生成コードでは使用しません。
- **運用方針:** Drizzle の `casing: 'snake_case'` 構成を利用し、テーブル・カラムは `snake_case` で統一します（参考: [Drizzle ドキュメント](https://orm.drizzle.team/docs/sql-schema-declaration#camel-and-snake-casing)）。
- **命名ガード:** データベース名、スキーマ名、テーブル名、カラム名、インデックス名など全識別子は 63 文字以内で明確な意味を持たせ、略語は最低限に留めます。
- **Drizzle スキーマ:** Supabase の宣言的スキーマと整合するように、Drizzle の `pgTable` 定義は Supabase マイグレーションと同一ソース（例: `src/db/schema/*.ts`）を真実の源泉とし、マイグレーション生成前に命名を自動検証します。

## 3. UI/UX とアクセシビリティ

### 3.1. UI/UX 基本方針

- **直感的なデザイン:** ユーザーインターフェースは直感的で使いやすく設計します。
- **レスポンシブデザイン:** 様々なデバイス (PC、タブレット、スマートフォン) での表示を最適化するため、レスポンシブデザインを採用します。
- **アニメーションとトランジション:** ユーザー体験を向上させるために、アニメーションやトランジションを適切かつ効果的に使用します。
- **タグ入力の補完:** 一度入力したタグは、次回入力時に補完されるようにします。

### 3.2. アクセシビリティ

- **キーボード操作:** 全てのインタラクティブな要素がキーボードのみで操作できるようにします。
- **ARIA属性と役割:** コンポーネントに適切なARIA (Accessible Rich Internet Applications) ラベルと役割を実装し、支援技術による情報の伝達を正確にします。
- **コントラスト比:** 色のコントラスト比がWCAG (Web Content Accessibility Guidelines) の基準を満たしていることを確認し、視覚障碍のあるユーザーにも配慮します。

## 4. 採用技術スタックと詳細な活用方針

### 4.1. Next.js と React

- 常に最新バージョンのReactとNext.jsを使用します。
- Next.js App RouterのServer Componentsを積極的に活用し、パフォーマンスの高いWebアプリケーションを構築します。

### 4.2. Hono (API)

- APIの実装には、軽量で高速なWebフレームワークであるHonoを使用します。
- **ルーティング:** シンプルかつ直感的に記述します。
- **ミドルウェア:** 認証やエラーハンドリングなどの共通処理は、Honoのミドルウェアを活用して効率的に実装します。
- **型安全性:** TypeScriptの型定義を適切に使用し、型安全なAPI開発を徹底します。
- **エコシステム活用:** 必要に応じて、Honoの提供するエコシステム (例: `hono/jwt`, `hono/cors`) を活用します。

### 4.3. Next.js サーバーアクション

- Next.jsのサーバーアクションを積極的に使用します。
- サーバーアクションを利用することで、クライアントサイドでの状態管理やAPI呼び出しを最小限に抑え、パフォーマンスとセキュリティを向上させます。
- **入力バリデーション:** 入力データのバリデーションにはZodを使用します。
- **エラー処理:** 適切なエラー処理を実装し、ユーザーに分かりやすいエラーメッセージを提供します。
- **戻り値のモデル化:** サーバーアクションの戻り値として、成功時とエラー時の両方のケースを明確にモデル化します。

## 5. ドキュメンテーション

- **コメント:** 複雑なロジックや理解が難しい箇所には、明確で簡潔なコメントを記述します。
- **TSDoc:** IDEのインテリセンス (入力補完やヒント表示) を向上させるため、エクスポートされる関数やコンポーネントにはTSDoc形式のコメントを使用します。
- **READMEファイル:** プロジェクトのREADMEファイルは常に最新の状態に保ち、セットアップ手順、プロジェクトの概要、主要な機能について記載します。
- **Supabase関連ドキュメント:** Supabaseのスキーマ定義、RLS (Row Level Security) ポリシー、およびEdge関数やStripe Webhook設定を使用する場合は、それらの設計や意図に関するドキュメントを作成します。

---
