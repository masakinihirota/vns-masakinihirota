---
trigger: always_on
---

# データベース設計・運用基準 (Database Best Practices)

Supabase (PostgreSQL) を利用したデータベース設計、クエリ実装、運用におけるベストプラクティスを定義します。

## 1. スキーマ設計 (Schema Design)

### 正規化と命名規則
- **正規化**: 原則として第3正規形まで正規化を行う。パフォーマンス上の理由で非正規化する場合は、その理由をドキュメント（コメント）に残す。
- **テーブル名**: 複数形、スネークケース（例: `users`, `user_profiles`, `order_items`）。
- **カラム名**: スネークケース（例: `created_at`, `is_active`）。
- **主キー**: 原則として `uuid` 型の `id` カラムを使用する（`gen_random_uuid()` デフォルト）。

### インデックス設計
- **外部キー**: JOINで使用される外部キーカラムには必ずインデックスを貼る。
- **検索・フィルタ**: `WHERE` 句で頻繁に使用されるカラム、ソートに使用されるカラムにインデックスを検討する。
- **過剰なインデックスの回避**: 書き込み性能への影響を考慮し、不要なインデックスは作成しない。

### セキュリティ (RLS)
- **RLS 必須**: 全てのテーブルに対して `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` を適用する。
- **ポリシーの明示**: 読み取り（SELECT）、作成（INSERT）、更新（UPDATE）、削除（DELETE）それぞれのポリシーを定義する。「フルオープン」なポリシーは開発環境を除き禁止。

## 2. クエリ最適化 (Query Optimization)

### N+1問題の回避
- **ループ内クエリの禁止**: 配列に対するループ処理の中でSQLを発行しない。
- **Eager Loading**: 必要な関連データは `select('*, related_table(*)')` 等を用いて一括取得する。

### ページネーション
- **サーバーサイド実装**: 大量データを返すクエリには必ず `limit` と `offset`（またはカーソルベース）によるページネーションを実装する。全件取得は禁止。

### 必要なカラムのみ取得
- **`select(*)` の制限**: `select(*)` は開発時のみとし、本番コードでは必要なカラムを明示的に指定する（`select('id, name, email')`）。これにより転送量を削減し、意図しないデータ漏洩を防ぐ。

## 3. マイグレーション (Migrations)

### マイグレーションファイルの管理
- **バージョン管理**: マイグレーションファイルは日時プレフィックス等で順序管理する。
- **SQL記述**: DDL操作（CREATE, ALTER, DROP）は必ずマイグレーションファイルで行い、Supabase Dashboardでの直接操作は行わない（本番環境との乖離を防ぐため）。

### 安全な変更
- **非互換変更の回避**: カラム削除や型変更など、アプリケーションコードを破壊する変更は、段階的に行う（カラム追加 → コード変更 → 前方互換維持 → カラム削除）。
- **ロールバック**: 可能な限りダウンマイグレーション（ロールバック用SQL）を考慮する。

## 4. Supabase固有の機能

### Realtime
- **必要な場合のみ有効化**: 全テーブルでRealtimeを有効にせず、リアルタイム更新が必要なテーブルのみ `supabase_realtime` パブリケーションに追加する。

### Function / Trigger
- **ロジックの所在**: 複雑なビジネスロジックをDB関数（PL/pgSQL）に持たせすぎない。バグ追跡が困難になるため、可能な限りアプリケーション層で実装する。ただし、データの整合性維持（Triggerによる更新日時自動更新など）はDB層で行う。
