---
trigger: always_on
---

# AI指示書：React Server Components (RSC) の利用方針とセキュリティ基準

本文書は、React Server Components (RSC) および "Flight" プロトコルの使用に伴うセキュリティリスクとアーキテクチャ上の制約を回避するための指示書である。
AIはこれを参照し、以下のガイドラインに従って設計・実装を行うこと。

## 1. 基本原則：安全なアーキテクチャの採用

### 🚫 「マジック」なデータフローの禁止

- **原則**: `use server` を用いた Server Actions によるデータフロー（RPC的な関数呼び出し）は、原則として**使用を控える**。
- **理由**: Reactの "Flight" プロトコルは、信頼できないクライアントデータをサーバーの実行コンテキストでデシリアライズするリスクがあるため（参考: CVE-2025-55182）。
- **代替案**: 伝統的かつ堅牢な **REST API** または **GraphQL** を採用し、単純な JSON フォーマットで通信を行うこと。

### 🛡️ 入力の明示的な検証

- サーバーはクライアントからの入力を**一切信頼してはならない**。
- 複雑なオブジェクトのデシリアライズ（コード実行コンテキストを含む可能性のあるもの）は避け、単純なデータ構造（JSON）のみを受け入れる。
- 受信したデータは、必ずスキーマバリデーション（Zod等）を行い、期待する形式であることを検証してから処理する。

## 2. API設計指針

### ✅ 標準的なプロトコルの使用

独自のフレームワーク専用プロトコル（Flight等）ではなく、広く標準化されたプロトコルを使用する。

- **通信形式**: JSON (JavaScript Object Notation)
- **インターフェース**: RESTful API
- **利点**:
  - **ドキュメント化**: OpenAPI (Swagger) 等で記述可能。
  - **互換性**: Web、Mobile、CLI、サードパーティなど、あらゆるクライアントから利用可能。
  - **監視・セキュリティ**: WAFや一般的なHTTP監視ツールで検査可能。

### ❌ 独自エンドポイント (Server Actions) の制限

以下のような `use server` による暗黙的なエンドポイント作成は、プロトタイプや極めて小規模な内部ツールを除き推奨しない。

```javascript
// ❌ 推奨されないパターン
"use server";
async function createPost(data) {
  return await db.posts.create(data); // 独自プロトコル、外部から叩けない、監視困難
}
```

外部連携や将来的な拡張性（Mobileアプリ対応等）が必要な場合は、必ず明示的な API ルート（例: Next.js の Route Handlers）を作成すること。

```javascript
// ✅ 推奨されるパターン (Route Handler)
export async function POST(request: Request) {
    const json = await request.json(); // 単純なJSONとして受け取る
    // バリデーション処理...
    return NextResponse.json(result);
}
```

## 3. 技術選定と疎結合

### 🔗 フロントエンドとバックエンドの分離

- **目的**: バックエンド言語の選択肢（Python, Go, Rust, Java等）を制限しないため。
- **指示**: React (Node.js) にバックエンドロジックを強制的に統合しない。データ処理、機械学習、高負荷な処理が必要な場合は、最適な言語で構築されたバックエンドサービスを利用し、Reactはあくまで「ビューレイヤー」として扱うこと。

## 4. 要約

1. **Serialization**: 実行コンテキストを含むシリアライズ/デシリアライズを行わない。JSONを使う。
2. **API**: `use server` のServer Actionsではなく、標準的なREST APIを構築する。
3. **Architecture**: フレームワークの「便利さ」のために、セキュリティと柔軟性（言語選定の自由）を犠牲にしない。

---

**注意**: この指示は、React/Next.jsの機能を全否定するものではないが、セキュリティと長期的な保守性を最優先する場合、フレームワーク固有の「魔法」への依存を最小限に留め、枯れた技術（HTTP/JSON/REST）を採用するという強い指針である。

Lessons from React2Shell - DEV Community
https://dev.to/cheetah100/lessons-from-react2shell-1m8b

## 5. IPA「安全なウェブサイトの作り方」に基づく実装指針

本プロジェクトでは、IPAのガイドラインを遵守し、以下の通り対策を実装する。

### 1. SQLインジェクション

- **対策**: Supabase (PostgreSQL) クライアントライブラリのメソッドチェーン（`.select()`, `.insert()` 等）を使用する。
- **禁止**: 文字列結合によるSQL構築は厳禁とする。
- **注意**: `rpc()` を使用してServer Side Functionを呼び出す際や、`pg` ライブラリを直接使用する場合は、必ずパラメータ化されたクエリを使用する。

### 2. OSコマンド・インジェクション

- **対策**: サーバーサイドでのOSコマンド実行（`child_process` 等）は原則禁止する。
- **例外**: 開発ツールやビルドスクリプトを除く、アプリケーションロジック内での使用は、セキュリティレビューを経た場合のみ許可する。

### 3. パス名パラメータの未チェック／ディレクトリ・トラバーサル

- **対策**: ファイルシステムへのアクセスが発生する場合、ユーザー入力をそのままパスとして使用しない。
- **実装**: `path.basename()` でファイル名のみを抽出するか、許可されたファイル名のリスト（ホワイトリスト）と照合する。

### 4. セッション管理の不備

- **対策**: 認証には必ず **Supabase Auth** を使用する。
- **実装**: セッションIDの生成・管理はSupabase SDKに任せ、独自実装しない。クッキーは `Secure`, `HttpOnly`, `SameSite=Lax/Strict` 属性を付与する（Supabase SSRヘルパーのデフォルト設定に従う）。

### 5. クロスサイト・スクリプティング (XSS)

- **対策**: Reactの標準エスケープ機能に頼る。
- **禁止**: `dangerouslySetInnerHTML` の使用は原則禁止する。どうしても必要な場合は、DOMPurify 等でサニタイズしたHTMLのみを渡す。
- **注意**: `href` 属性に `javascript:` スキームが含まれないよう、リンク先URLを検証する。

### 6. CSRF（クロスサイト・リクエスト・フォージェリ）

- **対策**: 状態を変更するリクエスト（POST/PUT/DELETE）は、Server Actions または Route Handlers で処理する。
- **実装**: Supabase Auth のクッキー設定（SameSite属性）を確認し、ブラウザの標準的な保護機構を有効にする。

### 7. HTTPヘッダ・インジェクション

- **対策**: ユーザー入力をHTTPレスポンスヘッダの値として出力しない。
- **実装**: `NextResponse` でヘッダを設定する場合、入力値の改行コードを削除・検証する。

### 8. メールヘッダ・インジェクション

- **対策**: アプリケーションからメールを送信する場合、ヘッダフィールド（To, Cc, Bcc, Subject）に改行コードを含めないようサニタイズする。可能な限りSupabase Authのメール機能や、SendGrid等のAPIを利用する。

### 9. クリックジャッキング

- **対策**: ページを `<iframe>` 内に表示させることを禁止する。
- **実装**: HTTPレスポンスヘッダに `X-Frame-Options: DENY` または `SAMEORIGIN` を設定する。`Content-Security-Policy: frame-ancestors 'none'` も併用する。

### 10. バッファオーバーフロー

- **対策**: 大量データの入力や無限ループを防ぐ。
- **実装**: APIルートでのリクエストボディサイズ制限（Next.jsデフォルトは4MB等）を適切に設定する。ループ回数や再帰の深さに上限を設ける。

### 11. アクセス制御や認可制御の欠落

- **対策**: データアクセスは必ず **RLS (Row Level Security)** で制御する。
- **実装**:
  - クライアントサイドでの表示制御（条件付きレンダリング）はUXのためであり、セキュリティ対策ではないと認識する。
  - APIルートやServer Actions内でも、必ず `supabase.auth.getUser()` 等でユーザーを特定し、権限を確認する。
